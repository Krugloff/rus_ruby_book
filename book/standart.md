# Встроенные типы данных

Каждый язык программирования поддерживает один или несколько встроенных типов данных. Экземпляры стандартных типов создаются без явного указания класса создаваемого объекта - он вычисляется автоматически на основе существующих лексических правил.

## Простые типы данных

К простым типам данных относятся числа, текст, логические величины, идентификаторы и регулярные выражения. Такие типы данных - это базовые блоки для построения других типов. На их основе создаются все остальные классы.

### Числа (Numeric)

#### Целые числа (Integer)

+ Целые числа, занимающие в памяти не более 31-го бита, относятся к классу Fixnum.
+ Целые числа, превышающие этот размер, относятся к классу Bignum.
+ Преобразование между типами чисел происходит автоматически.

Лексема числа - это обычный набор цифр (1289). Для разделения разрядов может использоваться символ подчеркивания (`_`), который будет игнорироваться интерпретатором. Однако этот знак нельзя использовать в начале или в конце лексемы (`1_000_000` - соответствует одному миллиону).

###### Системы счисления:

+ По умолчанию, все числа обрабатываются в десятичной системе счисления. Результат любых вычислений также преобразуется в десятичную систему;

+ Числа, начинающиеся с приставки 0x или 0X, обрабатываются в шестнадцатеричной системе счисления (0х4AF);

+ Числа, начинающиеся с приставки 0b или 0B, обрабатываются в двоичной системе счисления (0b0111).

Для записи отрицательных чисел используется знак "минус" (`-`).

Для записи положительных чисел используется знак "плюс" (`+`).  По умолчанию все числа обрабатываются как положительные.

#### Десятичные дроби (Float)

Лексема десятичной дроби - это группа цифр, разделенных десятичной точкой на две части: целую и дробную (`123.051`).

Так же можно использовать научную или экспоненциальную нотацию. При этом после числа записывается символ экспоненты (e или Е), после которого следует отрицательное или положительное число, обозначающее показатель степени 10 (`123е-10` - соответствует `$123 * 10^{-10}$`).

При записи десятичных дробей для разделения разрядов может использоваться символ подчеркивания (`_`), который будет игнорироваться интерпретатором.

### Текст (String)

Текст - это набор из одного или более символов. Символ - это любой отображаемый на экране знак.

~~~~~ note
Обычно этот тип данных называют строками. Несмотря на то, что текст может содержать символ перевода строки, он все равно рассматривается как одна большая строка. Я решил использовать термин "текст" чтобы избежать путаницы между понятиями строки кода (line), строки как объекта (string) и строки текста. В английском языке для каждой из строк существует отдельный термин, который при переводе на русский теряет смысловую нагрузку.
~~~~~

**Простой текст:** группа символов, ограниченная одиночными кавычками (`'Ruby'`).

Простой текст обрабатывается в том виде, в котором записан.

В простом тексте также распознается минимальный набор спецсимволов (называемых также управляющими или экранированными последовательностями). Спецсимвол - это группа из одного или более символов, теряющих своё индивидуальное значение, одновременно с приобретением этой группой нового значения.

##### Спецсимволы:

`\'` - соответствует символу одиночной кавычки;

`\\` - соответствует символу обратной косой черты.

*****

**Составной текст:** группа символов, ограниченная двойными кавычками (`"Ruby"`).

Составной текст обрабатывается интерпретатором с распознаванием полного набора спецсимволов и поддержкой интерполяции.

Интерполяция - это выполнение фрагментов кода `"#{выражение}"` и замена их на результат выполнения выражения (`"#{1+2}"` - соответствует тексту "3").

В составном тексте также разрешается использовать другие парные символы двойных кавычек.

##### Спецсимволы:

`\*` - соответствует любому символу на месте *, который необходимо сохранить в тексте. Используется для экранирования символов. Поэтому спецсимволы также называют экранированными последовательностями - все они начинаются с обратной косой черты;

`\b` - удаление предыдущего символа;

`\r` - возврат указателя курсора на начало строки. Запись следующего символа удалит все предыдущие (символ возврата каретки). Спецсимвол используется для вставки новой строки вместо предыдущей. Это полезно для замены строк в различных программах (например отображение хода выполнения программы в терминале).

`\n` - перевод указателя курсора на начало новой строки (символ перевода строки). Для операционной системы Windows в качестве символа перевода строки используется спецсимвол `\r\n`.

`\t` - перевод указателя курсора вправо, создавая отступ (табуляцию);

`\***` - соответствует символу, с указанной кодовой позицией из трех цифр в восьмеричной системе счисления;

`\**` - соответствует `\0**`;

`\*` - соответствует `\00*`;

`\x**` - соответствует символу, с указанной кодовой позицией;

`\x*` - соответствует `\x0*`;

`\u****` - соответствует символу, с указанной кодовой позицией в стандарте Юникод;

`\u{*}` – соответствует группе символов, с указанными кодовыми позициями в стандарте Юникод.

*****

**Специальная форма записи:** приставки `%q` или `%Q`.

Текст также может быть записан между двумя произвольными разделителями с использованием приставок `%q` или `%Q`. Разделитель – это символ или группа символов, которая служит границами текста. При использовании приставки `%q` текст будет распознаваться как простой, а при использовании приставки `%Q` - как составной (`%Q(Ruby)` - соответствует тексту `Ruby`). Вместо приставки `%Q`  также можно использовать только знак процента (`%(Ruby)`).

**Документы:** большие блоки текста, с многочисленными знаками препинания.

Лексема документа начинается с символов `<<` или `<<-`. За ними следует группа символов, которая будет служить границей текста.

Тело документа (текст) начинается со следующей строки. Объект создается, когда на отдельной строке будет использован разделитель. После создания объекта интерпретатор продолжит обработку кода с того места, на котором встретил начало лексемы.

+ Когда лексема начинается с `<<`, пробелы между началом строки и конечным разделителем не допускаются. Пробелы после конечного разделителя не допускаются никогда;

+ Когда начальный разделитель не ограничен кавычками, лексема распознается как составной текст. Чтобы сохранить простой текст начальный разделитель ограничивают одинарными кавычками. Кавычки также позволяют использовать пробелы внутри разделителя (в данном случае в качестве разделителя будет выступать объект).

~~~~~ ruby
  <<- 'DOC'
    Здесь записан простой текст.
  DOC
  # -> 'Здесь записан простой текст'
~~~~~

**Одиночный символ:** символ, начинающийся со знака вопроса ?.

При использовании лексемы распознаются некоторые спецсимволы, в основном относящиеся к способам записи символов с помощью кодовых позиций (`?A` – соответствует тексту 'A').

### Логические величины

Логические величины используются для булевой алгебры, проверки различных условий или сравнении объектов.

##### Список лексем:

`Истина:` true, ссылается на единственный экземпляр класса TrueClass;

`Ложь:` false, ссылается на единственный экземпляр класса FalseClass;

`Отсутствие:` nil, ссылается на единственный экземпляр класса NilClass. Используется в том случае, если необходимо представить отсутствие объекта, подходящего под заданные условия.

*****

При использовании в выражениях лексемы false и nil имеют логическое значение false, а все остальные объекты - логическое значение true.

Иногда также говорят о положительном результате (логическое значение true) и отрицательном (логическое значение false).

### Идентификаторы (Symbol)

Довольно часто для управления программой используются небольшие группы символов. Из-за особенностей реализации использование для этого текстовых объектов снижает скорость выполнения программы. Вместо этого рекомендуется использовать экземпляры класса Symbol.

Лексема объекта-идентификатора - это группа символов, следующая за двоеточием (`:green`). Также идентификатор может быть записан между двумя произвольными разделителями, с использованием приставок `%s` или `%S`. При использовании приставки `%s` группа символов распознается как простой текст, а при использовании `%S` - как составной.

(`%s(Ruby)` соответствует объекту-идентификатору `:'Ruby'`)

Для каждого идентификатора, кроме текста, сохраняется также цифровой код, вычисленный на его основе. При повторном использовании той же эмблемы, вместо создания нового объекта, по цифровому коду будет найден уже существующий. Использование цифровых кодов ускоряет поиск и сравнение объектов.

~~~~~ note
Однажды созданный объект-идентификатор будет существовать до закрытия программы, поэтому необходимо осторожно подходить к их использованию и делать это только по назначению (с целью управления процессом выполнения программы). Динамическое создание множества идентификаторов увеличивает количество памяти, занимаемой программой.
~~~~~

### Регулярные выражения (Regexp)

Регулярные выражения - это мощный инструмент для поиска по тексту. С помощью регулярных выражений составляются образцы, на основе которых выполняется поиск.

Лексема регулярного выражения - это группа символов (называемая телом регулярного выражения), ограниченная двумя косыми чертами (slash - /). После конечного разделителя может быть использован необязательный модификатор, влияющий на механизм поиска (`/Ruby/i`).

Тело регулярного выражения также может быть записано между двумя произвольными разделителями с использованием приставки `%r`. Модификаторы в этом случае записываются после конечного разделителя (`%r(Ruby)i` – соответствует `/Ruby/i`).

Тело регулярного выражения обрабатывается как составной текст. Одиночные символы, не относящиеся к спецсимволам соответствуют их аналогам в тексте.
Поиск совпадений выполняется последовательно по каждому символу, слева направо.

Полный синтаксис регулярных выражений описывается в [приложении](appregexp).

## Составные типы данных

Составные объекты -  это объекты, содержащие произвольный набор элементов (любых других объектов). Составные типы позволяет группировать объекты и рассматривать их на уровне группы.

### Индексные массивы (Array)

Индексный массив (или просто массив) - это составной объект, содержащий упорядоченную группу элементов и позволяющий получить доступ к элементу, если известна его позиция (индекс элемента). Элементами массива могут быть любые объекты (даже другие массивы).

С точки зрения синтаксиса, индексные массивы - это группа объектов между двумя квадратными скобками. Сами объекты при этом разделяются запятыми.

`[1, "Ruby", ?\u0048]`

Существует также специальный синтаксис записи массивов, в качестве элементов которых выступают короткие отрывки текста (состоящие из одного слова и не содержащие пробелов). Такие массивы могут быть записаны в виде группы элементов между двумя произвольными разделителями с использованием приставок `%w` или `%W`. Сами элементы при этом разделяются пробелами.

При использовании приставки `%w` элементы массива будут рассматриваться как простой текст, а при использовании приставки `%W` - как составной.

`%W( Язык программирования Ruby )` соответствует массиву:

`[ "Язык", "программирования", "Ruby" ]`

**Во второй версии Ruby** добавлен специальный синтаксис записи массивов, в качестве элементов которых выступают объекты-идентификаторы. Такие массивы могут быть записаны в виде группы элементов между двумя произвольными разделителями с использованием приставок `%i` или `%I`. Сами элементы при этом разделяются пробелами.

При использовании приставки `%i` элементы массива будут рассматриваться как простой текст, а при использовании приставки `%I` - как составной.

`%I( category klass )` соответствует массиву:

`[:category, :klass]`

### Ассоциативные массивы (Hash)

Ассоциативный массив - это составной объект, содержащий упорядоченную группу элементов (каждый из которых представляет собой пару ключ/значение) и позволяющий получить доступ к значению, если известен его ключ (ключ ассоциируется с объектом).

~~~~~ note
Для построения соответствий между ключами и значениями используется виртуальная таблица.

Объекты, выступающие в роли ключей, в таблице представлены в виде цифровых кодов (небольших целых чисел), получаемых в результате вызова метода `.hash`. Соответственно сам ключ может быть объектом любого типа, если для него определен этот метод.
~~~~~

В ассоциативном массиве можно хранить любые объекты (даже другие массивы).

С точки зрения синтаксиса, ассоциативные массивы - это группа парных элементов ключ/значение между двумя фигурными скобками. Ключи от значений отделяются символами `=>`. Сами элементы при этом разделяются запятыми.

`{ "Ruby" => "language", "Вася" => "Человек" }`

Один из наиболее распространенных способов использования объектов-идентификаторов - в качестве ключей ассоциативного массива. При этом ассоциативный массив записывают в коде программы, отделяя ключи от значений двоеточием (при этом двоеточие перед ключом не используется).

`{ Ruby: "language", Вася: "Человек" }`

соответствует ассоциативному массиву:

`{ :Ruby => "language",  :Вася => "Человек" }`

### Диапазоны (Range)

Диапазон - это составной тип данных, содержащий упорядоченный набор объектов, располагающихся между заданными границами.

С точки зрения синтаксиса, диапазоны - это два однотипных объекта, разделенные двумя или тремя точками. При использовании двух точек в диапазон включается конечная граница (`1..3` содержит числа 1, 2, 3), а при использовании трех - нет (`1...3` содержит числа 1 и 2).

~~~~~ note
Границы диапазона должны принадлежать к одному классу. В этом классе должен быть определен оператор `<=>`, использующийся для сравнение объектов, входящих в диапазон, с его границами.
~~~~~
