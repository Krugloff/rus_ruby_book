## Предложения

Предложение - это одна из разновидностей сложных выражений, создаваемая с помощью инструкций (поэтому количество возможных видов предложений строго ограничено). Каждое предложение начинается с инструкции, объявляющей тип предложения и заканчивается инструкцией end, объявляющей конец предложения. Между этими двумя инструкциями находится фрагмент кода, называемый телом предложения, ходом выполнения которого манипулирует предложение.

### Условное предложение

Условные предложения управляют ходом выполнения в зависимости от логического значения переданного условия. В результате выполнения предложения возвращается результат выполнения последнего выражения в его теле (или nil).

+ Тело предложения выполняется при положительном результате вычисления условия.

~~~~~ ruby
  if true
    a = 1
  end
~~~~~

+ Тело предложения должно быть отделено от условия либо переводом строки, либо точкой с запятой, либо инструкцией then.

~~~~~ ruby
  if true then a = 1 end
  if true; a = 1 end
~~~~~

+ Необязательная инструкция else содержит фрагмент кода, который выполняется при отрицательном результате вычисления условия.

~~~~~ ruby
  if true
    a = 1
  else
    a = 2
  end
~~~~~

+ При необходимости записать подряд инструкцию else и новое условное предложение используется инструкция elsif.

~~~~~ ruby
  if true
    a = 1
  elsif false
    a = 2
  end
~~~~~

+ Существует краткий синтаксис для записи предложения, помещающего на одной тсроке кода.

~~~~~ ruby
  a = 1 if true
~~~~~

+ Если вместо инструкции if использовать инструкцию unless, то тело предложения будет выполняться при отрицательном результате вычисления условия. Инструкция elsif в этом случае не используется.

~~~~~ ruby
  unless true
    a = 1
  end
~~~~~

### Разветвленное условие

Разветвленные условия похожи на условные предложения, но позволяют проверять сразу несколько условий. Условия проверяются последовательно. Обычно наиболее вероятные варианты записывают раньше остальных - это уменьшит время выполнения предложения. В результате выполнения предложения возвращается результат выполнения последнего выражения в его теле (или nil).

+ Выполняется фрагмент кода с положительным результатом вычисления условия.

~~~~~ ruby
  case
    when a == 1
      b = 1
    when a == 2
      b = 2
  end
~~~~~

+ Условие может состоять из нескольких выражений, разделенных запятыми. Любое из них может послужить причиной для выполнения кода.

~~~~~ ruby
  case
    when a == 0, a == 1
      b = 1
    when a == 2
      b = 2
  end
~~~~~

+ Существует также специальная форма записи. Указанные значения сравниваются с условием (с помощью `===`).

~~~~~ ruby
  case a
    when 1
      b = 1
    when 2
      b = 2
  end
~~~~~

+ В любой форме можно использовать инструкцию else. Она будет выполняться если условие не было удовлетворено.

~~~~~ ruby
  case
    when a == 1
      b = 1
    when a == 2
      b = 2
    else
      b = 3
  end
~~~~~

### Цикл

Цикл - это предложение итеративного типа (заставляющее программу повторно выполнять некоторый фрагмент кода). Циклы используются в том случае, когда число итераций неизвестно заранее. В результате выполнения цикла возвращается ссылка на nil.

+ Тело предложения выполняется до тех пор пока результат вычисления условия истинен (условие проверяется до итерации).

~~~~~ ruby
  while a < 3
    a = a + 1
  end
~~~~~

+ Тело цикла должно быть отделено от условия либо переводом строки, либо точкой с запятой, либо инструкцией do.

~~~~~ ruby
  while a < 3 do a = a + 1 end
~~~~~

~~~~~ ruby
  while a < 3; a = a + 1 end
~~~~~

+ Существует также специальный синтаксис для циклов, помещающихся на одной строке кода.

~~~~~ ruby
  a = a + 1 while a < 3
~~~~~

+ Тело цикло может быть ограничено инструкциями begin и end

+ Если вместо инструкции while использовать инструкцию until (эквивалентно конструкции while not), то тело цикла будет выполняться до тех пор пока результат вычисления условия ложен.

~~~~~ ruby
  until a < 3
    a = a + 1
  end
~~~~~

~~~~~ note
Инструкция, на самом деле, в точности не соответствует слову "пока" в естественном языке. Условие цикла не проверяется непрерывно, а только до или после каждой итерации.
~~~~~

### Перебор элементов

Перебор элементов - это предложение итеративного типа, выполняющее фрагмент кода для каждого элемента составного объекта.

+ Тело предложения выполняется для каждого элемента, который присваивается переданному идетнификатору.

~~~~~ ruby
  for i in [1, 2, 3]
    a = i + 1
  end
~~~~~

+ Тело предложения должно быть отделено либо переводом строки, либо точкой с запятой, либо инструкцией do.

~~~~~ ruby
  for i in [1, 2, 3] do a += i end
  for i in [1, 2, 3]; a += i end
~~~~~

+ Идентификатор существует даже после выполнения предложения.

~~~~~ ruby
  for i in [1, 2, 3] do a += i end
  i # -> 3
~~~~~

### Процесс выполнения

Процессом выполнения предложений (итеративного типа) можно манипулировать с помощью специальных инструкций в его теле. Инструкции могут принимать результат выполнения предложения (если он не указан, то результатом будет nil).

##### Инструкции:

`break [result]` - используется для завершения выполнения предложения;

~~~~~ ruby
a = 0

while a < 3
  a += 1
  break a if a == 2
end
~~~~~

`next [result]` - используется для завершения текущей итерации и начала следующей;

~~~~~ ruby
a = 0

while a < 3
  a += 1
  next a if a == 2
end
~~~~~

`redo` - используется для повторного выполнения текущей итерации. Проверка условия при этом не выполняется.

~~~~~ ruby
a = 0

while a < 3
  a += 1
  redo if a == 2
end
~~~~~

*****

### Триггеры (flip flop)

В качестве условия могут быть использованы триггеры. Триггер - это сложное выражение, составленное с помощью операторов `..` или `...`.

~~~~~ ruby
if activate..deactivate
  code
end
~~~~~

Как и обычные условия, триггеры имеют некоторое логическое значение. Его особенность в том, что оно может изменяться в зависимости от результатов предыдущих вычислений, т.е. триггер сохраняет состояние выполнения.

Обычно триггеры применяются вместе с регулярными выражениями для обработки текста между начальными и конечными шаблонами.

~~~~~ ruby
array = [
  "# Код ниже будет извлекать все фрагменты текста, начинающиеся с 'begin' и заканчивающиеся 'end'",
  "begin",
  "a = 1",
  "end",
  "# И этот фрагмент тоже",
  "begin",
  "b = 2",
  "end"
]

result = []

for line in array
  result << line if (line =~ /^begin/)...(line =~ /^end/)
end

result == [
  "begin",
  "a = 1",
  "end",
  "begin",
  "b = 2",
  "end"
]

result = []

for line in array
  result << line if (line =~ /^begin/)..(line =~ /^end/)
end
~~~~~

Операнды триггера - это два условия, при проверке которых выполняется активация (значение триггера - true) или дезактивация (значение триггера - false) триггера. Порядок проверки условий зависит от оператора, используемого для создания триггера.

1. Если триггер не активирован, то проверяется условие для активации. В зависимости от его логического значения устанавливается значение триггера. После этого для оператора `..` также проверяется условие для деактивации.

2. Если триггер активирован, то проверяется условие для деактивации. Если условие выполняется, то триггер деактивируется.

~~~~~ note
По смыслу триггеры чем-то похожи на диапазоны. Они позволяют выбрать все элементы между двумя границами (задаваемыми условиями).
~~~~~
