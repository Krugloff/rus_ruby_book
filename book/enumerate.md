# Составные объекты

**Добавленные модули: Enumerable**

## Array (индексные массивы)

`::new( size = 0, object = nil ) # -> array`

`(array) # -> array`

`(size) { |index| } # -> array`

Используется для создания индексного массива заданного размера. Элементы вычисляются с помощью блока или ссылаются на дополнительный аргумент.

~~~~~ ruby
  Array.new 3, ?R # -> ["R", "R", "R"]
  Array.new [1, 2] # -> [1, 2]
  Array.new(3) { |index| index**2 } # -> [0, 1, 4]
~~~~~

`::[*object] # -> array`

Используется для сохранения объектов в массив.  
`Array[1, 2, 3] # -> [1, 2, 3]`

### Приведение типов

`.to_a # -> array`  
Синонимы: `to_ary`

`::try_convert(object) # -> array`

Преобразование объекта в индексный массив с помощью вызова метода `object.to_ary`. Если для объекта этот метод не определен, то возвращается nil.  
`Array.try_convert 1 # -> nil`

`.to_s # -> string`  
Синонимы: `inspect`

Преобразование массива в текст.  
`[ 1, 2, 3 ].to_s # -> "[1, 2, 3]"`

`.join( sep = $, ) # -> string`

Используется для объединения элементов (join - "объединить", англ.), используя переданный разделитель (по умолчанию nil).

~~~~~ ruby
  [1, 2, 3].join # -> "123"

  [
    "#{msg}",
    "Class: <#{e.class}>",
    "Message: <#{e.message.inspect}>",
    "---Backtrace---",
    "#{MiniTest::filter_backtrace(e.backtrace).join("\n")}",
    "---------------",
  ].join "\n"
~~~~~

`.pack(format) # -> string`

Используется для упаковки массива в двоичный текст, с помощью [apppack](форматной строки).  
`[-1, -2, -3].pack "C*" # -> "\xFF\xFE\xFD"`

### Элементы

Для доступа к элементам используются операторы `[]` и `[]=`. Индексация элементов начинается с нуля. Если индекс отрицательный, то отсчет элементов ведется справа налево, начиная с -1.

~~~~~ note
Наиболее частая проблема с массивами - передача индекса, выходящего за пределы массива.
~~~~~

#### array.[*object]

Синонимы: `slice(*object)`

`.[index] # -> object`  
Синонимы: `at`

Используется для получения элемента с заданным индексом. Если индекс выходит за пределы массива, то возвращается nil.
~~~~~ ruby
  [1, 2, 3][2] # -> 3
  [1, 2, 3][4] # -> nil
~~~~~

`.[start, size] # -> array`

Используется для получения фрагмента массива заданного размера.

* Если количество элементов выходит за пределы массива, то возвращается вся часть массива до последнего элемента;
* Если количество элементов равно нулю, то возвращается ссылка на пустой массив (`[]`);
* Если количество элементов отрицательно, то возвращается nil;
* Если индекс выходит за пределы массива, то возвращается пустой массив.

~~~~~ ruby
  [1, 2, 3][2, 1] # -> [3]
  [1, 2, 3][2, 2] # -> [3]
  [1, 2, 3][2, 0] # -> [ ]
  [1, 2, 3][2, -1] # -> nil
  [1, 2, 3][3, 1] # -> [ ]
~~~~~

`.[range] # -> object`

Используется для получения указанного фрагмента массива.

* Если конечная граница выходит за пределы массива, то возвращается вся часть массива до последнего элемента;
* Если конечная граница меньше, чем начальная, то возвращается пустой массив;
* Если начальная граница выходит за пределы массива, то возвращается nil.

~~~~~ ruby
  [1, 2, 3][1...3] # -> [2, 3]
  [1, 2, 3][1...5] # -> [2, 3]
  [1, 2, 3][1...0] # -> [ ]
  [1, 2, 3][5...9] # -> nil
~~~~~

#### array.[*object]=

Используется для изменения значения объекта. В результате возвращается измененный элемент или массив элементов.

* Превышение конечной границы массива при водит к его расширению. Промежуточные элементы при этом ссылаются на nil.

* Выход за начальную границу массива считается исключением.

`.[index]=(object) # -> object`

Используется для изменения элемента с заданным индексом.

~~~~~ ruby
  [1, 2, 3][2] = "d" # -> "d"
  array # -> [1, 2, "d"]

  [1, 2, 3][4] = "d"  # -> "d"
  array # -> [1, 2, 3, "d"]
~~~~~

`.[start, size]=(object) # -> object`

Используется для изменения фрагмента массива заданного размера.

* Если количество элементов равно нулю, то выполняется вставка элементов.
* Отрицательный размер считается исключением.

~~~~~ ruby
  [1, 2, 3][4, 1] = "d" # -> "d"
  array # -> [1, 2, 3, nil, "d"]

  [1, 2, 3][3, 1] = "d" # -> "d"
  array # -> [1, 2, 3, "d"]

  [1, 2, 3][2, 1] = "d" # -> "d"
  array # -> [1, 2, "d"]

  [1, 2, 3][2, 2] = "d" # -> "d"
  array # -> [1, 2, "d"]

  [1, 2, 3][2, 0] = "d" # -> "d"
  array # -> [1, 2, "d", 3]

  [1, 2, 3][2, -1] = "d" # -> error!
~~~~~

`.[range]=(object) # -> object`

Используется для изменения указанного фрагмента массива. Если конечная граница меньше, чем начальная, то элементы добавляются перед индексом, заданным начальной границей диапазона.

~~~~~ ruby
  [1, 2, 3][1...2] = "d" # -> "d"
  array # ->[1, "d", 3]

  [1, 2, 3][1...5] = "d"# -> "d"
  array # -> [1, "d"]

  [1, 2, 3][1...0] = "d"# -> "d"
  array # -> [1, "d", 2, 3]

  [1, 2, 3][5...9] = "d"# -> "d"
  array # -> [1, 2, 3, nil, nil, "d"]
~~~~~

#### Остальное:

`.fetch(index, object) # -> object2`

`(index) { |index| } # -> object`

Аналогично выполнению `array[index]`. Дополнительный аргумент используется при выходе за пределы массива.  
`[ 1, 2, 3 ].fetch 3, 4 # -> 4`

`.values_at(*object) # -> array`

Аналогично выполнению `array[*object]` для каждого переданного объекта.  
`[ 1, 2, 3 ].values_at 1, 1 # -> [ 2, 2 ]`

`.sample( size = nil ) # -> object`

Используется для получения случайного элемента (или массива случайных элементов). Для пустых массивов возвращается nil или пустой массив соответственно. Если переданный размер равен или превышает размеры исходного массива, то в результате элементы просто перестраиваются в случайном порядке.  
`[ 1, 2, 3 ].sample 4 # -> [ 2, 1, 3 ]`

`.last(size = 1) # -> object`

Используется для получения последнего элемента или последнего фрагмента.  
`[ 1, 2, 3 ].last 2 # -> [ 2, 3 ]`

`.index(object) # -> integer`

`{ |object| } # -> integer`

Используется для поиска индекса элемента либо равного переданному объекту, либо с положительным результатом выполнения блока.  
`[ 1, 2, 3 ].index { |elem| elem < 3 } # -> 0`

`.rindex(object) # -> integer`

`{ |object| } # -> integer`

Версия предыдущего метода, выполняющая поиск элемента с конца массива.  
`[ 1, 2, 3 ].rindex { |elem| elem < 3 } # -> 1`

### Операторы

`.*(integer) # -> array` Копирование.

`.*(sep) # -> string`

Используется для объединения элементов в текст с использованием переданного разделителя.  
`[1, 2, 3] * ?? # -> "1?2?3"`

`.+(array) # -> new_array` Объединение элементов.

`.-(array) # -> new_array` Удаление элементов.

`.<<(object) # -> self` Добавление элемента. Изменяется значение объекта.

`.&(array) # -> new_array` Пересечение множеств.

`.|(array) # -> array` Объединение множеств.

### Изменение массивов

#### Работа со стеком

`.push(object) # -> self`

Используется для добавления элементов в конец массива. Изменяет значение объекта.  
`[1, 2, 3].push 2 # -> [1, 2, 3, 2]`

`.pop( size = 1 ) # -> object || array`

Используется для удаления элементов из конца массива.  
`[1, 2, 3].pop 2 # -> [2, 3]`

`.unshift(object) # -> self`

Используется для добавления элементов в начало массива.  
`[1, 2, 3].unshift 2 # -> [2, 1, 2, 3]`

`.shift( size = 1 ) # -> object || array`

Используется для удаления элементов из начала массива.  
`[1, 2, 3].shift 2 # -> [1, 2]`

#### Удаление элементов

`.clear # -> self`

Используется для удаления всех элементов. Изменяет значение объекта.  
`[ 1, 2, 3 ].clear # -> [ ]`

`.compact # -> array`

Используется для удаления элементов, ссылающихся на nil.  
`[ 1, 2, 3 ].compact # -> [ 1, 2, 3 ]`

`.compact! # -> self`

Версия предыдущего метода, изменяющая значение объекта.

`.uniq # -> array`

Используется для удаления повторяющихся элементов.  
`[ 1, 2, 3, 3, 2, 1 ].uniq # -> [ 1, 2, 3 ]`

`.uniq! # -> self`

Версия предыдущего метода, изменяющая значение объекта. Если ни один элемент не был удален, то возвращается nil.

`.slice!(*object) # -> delete`

Используется для удаления фрагментов массива `self[*object]`.  
`[1, 2, 3].slice! 1, 1 # -> [2]`

`.delete(object) { nil } # -> delete`

Используется для удаления всех элементов, равных переданному аргументу (изменяется значение объекта). Если ни один элемент не был удален, то возвращается либо nil, либо результат выполнения необязательного блока.

~~~~~ ruby
  [1, 2, 3].delete(4) { "error!" } # -> "error!"

  [1, 2, 3, 1].delete 1 # -> 1
  array # -> [2, 3]

  array = [2, 3, 4]
  [1, 2, 3].each { |elem| array.delete elem } # -> [1, 2, 3]
  array # -> [4]
~~~~~

`.delete_at(index) # -> delete`

Используется для удаления элемента с заданным индексом (изменяется значение объекта). Если ни один элемент не был удален, то возвращается nil.

~~~~~ ruby
  [1, 2, 3].delete_at 1 # -> 2
  array # -> [1, 3]
~~~~~

`.delete_if { |object| } # -> self`  
Синонимы: `reject!`

Используется для удаления всех элементов с положительным значением итерации (изменяется значение объекта). Если ни один элемент не был удален, то возвращается nil.  
`[1, 2, 3].delete_if { |elem| elem < 3 } # -> [3]`

`.select! { |object| } # -> self`

Используется для сохранения только элементов с положительным значением итерации (изменяется значение объекта). Если ни один элемент не был удален, то возвращается nil.
`[1, 2, 3].select! { |elem| elem < 3 } # -> [1, 2]`

#### Замена элементов

`.replace(array) # -> self`  
Синонимы: `initialize_copy`

Используется для замены значения объекта.  
`[1, 2, 3].replace [ ] # -> [ ]`

`.insert( *(index, *object) ) # -> self`

Аналогично выполнению `array[integer] = *object` для каждой пары переданных методу объектов.  
`[ 1, 2, 3 ].insert 1, 2, 3 # -> [ 1, 2, 3, 2, 3 ]`

`.fill( object, start = 0, size = self.size ) # -> self`

`( start = 0, size = self.size ) { |index| } # -> self`

`( object, range ) # -> self`

`(range) { |index| } # -> self`

Используется для замены всех элементов фрагмента массива заданного размера или диапазона (изменяется значение объекта). Новые объекты либо ссылаются на переданный аргумент, либо вычисляются в результате выполнения блока.  
`[1, 2, 3].fill 1 # -> [1, 1, 1]`

#### Остальное

`.flatten( deep = nil ) # -> array`

Используется для извлечения элементов из вложенных подмассивов до заданного уровня вложенности. По умолчанию извлекаются все элементы.  
`[ [[1]], [[2]], [[3]] ].flatten # -> [1, 2, 3]`

`.flatten!(deep) # -> self` Версия предыдущего метода, изменяющая значение объекта.

`.rotate( step = 1 ) # -> array`

Используется для вращения элементов массива на заданное число позиций - слева направо для положительного аргумента и справа налево для отрицательного.

~~~~~ ruby
  [1, 2, 3].rotate  # -> [2, 3, 1]
  [1, 2, 3].rotate -1  # -> [3, 1, 2]
~~~~~

`.rotate!( step = 1 ) # -> self` Версия предыдущего метода, изменяющая значение объекта.

### Сортировка массива

`.reverse # -> array`

Перестановка элементов в обратном порядке.  
`[1, 2, 3].reverse # -> [3, 2, 1]`

`.reverse! # -> self`

Версия предыдущего метода, изменяющая значение объекта.

`.shuffle # -> array`

Перестановка элементов в случайном порядке.  
`[1, 2, 3].shuffle # -> [2, 3, 1]`

`.shuffle! # -> self` Версия предыдущего метода, изменяющая значение объекта.

`.sort! # -> self`

`{ |object, object2| } # -> self`

Используется для сортировки элементов (изменяется значение объекта). Элементы сравниваются либо с помощью оператора `<=>`, либо на основе результатов итераций.

`.sort_by! { |object, object2| } # -> self`

Используется для сортировки элементов (изменяется значение объекта) в восходящем порядке на основе результатов итераций.

### Итераторы

`.each { |object| } # -> self` Перебор элементов.

`.each_index { |index| } # -> self` Перебор индексов.

`.collect! { |object| } # -> self`  
Синонимы: `map!`

Используется для замены элементов на результат их итерации (изменяется значение объекта). Часто применяется вместе с функциональным стилем программирования.

~~~~~ ruby
  [1, 2, 3].collect! { |elem| elem + 1 } # -> [2, 3, 4]
  [1, 2, 3].collect! &:to_s # -> ["1", "2", "3"]
~~~~~

`.combination(size) { |array| } # -> self`


Перебор всех возможные фрагментов заданного размера. Различный порядок элементов при этом игнорируется.

+ Если аргумент равен нулю, то итерируется `[[]]`;
+ Если аргумент больше, чем размер объекта, то итерируется пустой массив.

`.repeated_combination(size) { |array| } # -> self`

Версия предыдущего метода, в которой один и тот же элемент может использоваться несколько раз.

`.permutation( size = self.size ) { |array| } # -> self`

Версия метода, учитывающая различный порядок элементов.

`.repeated_permutation( size = self.size ) { |array| } # -> self`

Версия предыдущего метода, в которой один и тот же элемент может использоваться несколько раз.

### Ассоциативные массивы

`.assoc(key) # -> array`

Используется для поиска вложенного подмассива, первый элемент которого равен переданному аргументу. Если совпадений не найдено, то возвращается nil.  
`[ [:a, 1], [:b, 2], [:a, 3] ].assoc :a # -> [:a, 1]`

`.rassoc(object) # -> array`

Используется для поиска вложенного подмассива, второй элемент которого равен переданному аргументу. Если совпадений не найдено, то возвращается nil.  
`[ [:a, 1], [:b, 2], [:a, 3] ].rassoc :a # -> nil`

`.transpose # -> array`

Используется для извлечения из вложенных подмассивов первого и второго элементов. В результате возвращается объект, состоящий из двух вложенных подмассивов. Первый содержит все первые элементы, а второй - оставшиеся элементы.  
`[ [:a, 1], [:b, 1] ].transpose # -> [ [:a, :b], [1, 1] ]`

### Остальное

`.product(*array) # -> array2`

`(*array) { |part| } # -> array3`

Используется для получения всех возможных фрагментов размером self.size, созданных из элементов всех используемых массивов. Учитывается разный порядок элементов. Каждый элемент может быть использован в подмассиве только один раз.

+ При вызове без аргументов, фрагменты будут состоять из одного элемента;
+ Если методу передается пустой массив, то в результате также возвращается пустой массив.

~~~~~ ruby
  [1, 2].product [3] # -> [ [1, 3], [2, 3] ]
  [1, 2, 3].product # -> [ [1], [2], [3] ]
  [1, 2, 3].product [ ] # -> [ ]
~~~~~

`.bsearch { |x| } # -> elem [Ruby 2.0]`

Реализация двоичного поиска (метода деления пополам, дихотомии). Используется для нахождения элемента, который отвечает заданному условию за O(log n), где n - это размер массива. Алгоритм выполняет поиск элемента в отсортированном массиве, используя дробление массива на половины.

Метод реализован как в классическом варианте, так и для использования бисекции. В любом случае массив должен быть монотонным (отсортированным) по отношению к блоку.

+ Поиск элемента

  Блок должен возвращать логическую величину для каждого элемента. Массив должен содержать элемент с индексом i, так что:

  + Блок возвращает false для любого элемента, индекс которого меньше чем i.
  + Блок возвращает true для любого элемента, индекс которого больше или равен i.

  В результате возвращается элемент с индексом i. Когда индекс равен размеру массива, то возвращается nil.

  ~~~~~ ruby
    ary = [0, 4, 7, 10, 12]
    ary.bsearch {|x| x >=   4 } # -> 4
    ary.bsearch {|x| x >=   6 } # -> 7
    ary.bsearch {|x| x >=  -1 } # -> 0
    ary.bsearch {|x| x >= 100 } # -> nil
  ~~~~~

+ Метод бисекции (метод деления отрезка пополам)

  Простейший численный метод для решения нелинейных уравнений вида `F(x) = 0`.

  Блок должен возвращать число для каждого элемента. Массив должен содержать элементы с индексами i и j (`i <= j`), так что:

  + Блок возвращает положительное число для элементов с индексом `0...i`.
  + Блок возвращает ноль для элементов с индексом `i...j`.
  + Блок возвращает отрицательное число для элементов с индексом `j...size`.

  В результате возвращается любой из элементов с индексом из диапазона `i...j`. Если `i == j`, т.е. нет элементов, отвечающих условию, возвращается nil.

  ~~~~~ ruby
    ary = [0, 4, 7, 10, 12]
    # Поиск элемента из диапазона 4...8
    ary.bsearch {|x| 1 - x / 4 } # -> 4 или 7
    # Поиск элемента из диапазона 8...10
    ary.bsearch {|x| 4 - x / 2 } # -> nil
  ~~~~~

`.hash # -> integer`

Цифровой код объекта.  
`[1, 2, 3].hash # -> -831861323`

`.empty? # -> bool`

Проверка пуст ли массив.  
`[1, 2, 3].empty? # -> false`

`.size # -> integer`  
Синонимы: `length`

Количество элементов. Результат всегда на единицу больше, чем индекс последнего элемента.  
`[ 1, 2, 3 ].size # -> 3`

## Hash (ассоциативные массивы)

`::new( object = nil ) # -> hash`

`{ |hash, key| } # -> hash`

Используется для создания массива с переданным значением по умолчанию.

`::[ key, object ] # -> hash`

`[ *[key,object] ] # -> hash`

`[object] # -> hash`

Используется для создания массива на основе переданных аргументов.

~~~~~ ruby
  Hash[:Ruby, "languages", :Ivan, "man"]
  # -> { Ruby: "languages", Ivan: "man" }

  Hash[ [ [:Ruby, "languages"], [:Ivan, "man"] ] ]
  # -> { Ruby: "languages", Ivan: "man" }

  Hash[Ruby: "languages", Ivan: "man"]
  # -> { Ruby: "languages", Ivan: "man" }
~~~~~

### Приведение типов

`.to_hash # -> hash`

`.to_h # -> self [Ruby 2.0]`

Возвращает объект, для которого был вызван. Когда вызывается для производных классов, получатель преобразуется ассоциативный массив.

`::try_convert(object) # -> hash`

Преобразование объекта в массив, с помощью метода `object.to_hash`. Если для объекта этот метод не определен, то возвращается nil.  
`Hash.try_convert[1] # -> nil`

`.to_s # -> string`  
Синонимы: `inspect`

Преобразование массива в текст. Спецсимволы экранируются.  
`{ a: ?a, "b" => '\n' }.to_s # -> "{:a=>\"a\", \"b\"=>\"\\\\n\"}"`

`.to_a # -> array`

Преобразование ассоциативного массива в индексный вида `[ *[key, object] ]`. Спецсимволы экранируются.  
`{ a: ?a, "b" => '\n' }.to_a # -> [ [:a, "a"], ["b", "\\n"] ]`

### Элементы

`.[key] # -> object`

Используется для получения значения ключа. Если ключ не найден, то возвращается значение по умолчанию.  
`{ a: ?a, "b" => 1 }[:a] # -> "a"`

`.values_at(*key) # -> array`

Используется для получения значений нескольких ключей.  
`{ a: ?a, "b" => 1 }.values_at :a, :b, ?b # ->  ["a", nil, 1]`

`.select { |key, object| } # -> hash`

Используется для получения фрагмента массива, содержащего элементы с положительным результатом итерации.  
`{ a: ?a, "b" => 1 }.select { |key| key == ?b } # -> { "b"=>1 }`

`.key(object) # -> key`

Используется для получения ключа с переданным значением. Если ключ не найден, то возвращается nil.  
`{ a: ?a, "b" => 1 }.key ?a # -> :a`

`.keys # -> array`

Массив ключей.  
`{ a: ?a, "b" => 1 }.keys # -> [:a, "b"]`

`.values # -> array`

Массив значений.  
`{ a: ?a, "b" => 1 }.values # -> [ "a", 1 ]`

`.[key]=(object) # -> object`  
Синонимы: `store`

Используется для изменения содержимого массива.

~~~~~ ruby
  { a: ?a, "b" => 1 }[:a] = 2 # -> 2
  hash # -> { :a => 2, "b" => 1 }
~~~~~

`.fetch( key, default = nil ) # -> object`

`(key) { |key| } # -> object`

Используется для получения значения ключа. Отсутствие ключа считается исключением и может привести либо к остановке выполнения, либо к вычислению блока или дополнительного аргумента.  
`{ a: ?a, "b" => 1 }.fetch :b, ?a # -> "a"`

### Изменение массива

#### Добавление элементов

`.merge(hash) # -> hash2`

`(hash) { |key, self_value, arg_value| } # -> hash2`

Используется для объединения двух массивов. При совпадении ключей предпочтение отдается аргументу или результату выполнения блока.  
`{ a: ?a, "b" => 1 }.merge( { "b" => ?b } ) # -> { a: "a", "b" => "b" }`

`.merge!(hash) # -> self`

`(hash) { |key, self_value, arg_value| } # -> self`  
Синонимы: `update`

Версия предыдущего метода, изменяющая значение объекта.

#### Удаление элементов

`.clear # -> self`

Используется для удаления всех элементов (изменяется значение объекта).  
`{ a: ?a, "b" => 1 }.clear # -> { }`

`.shift # -> array`

Используется для удаления первого элемента (изменяется значение объекта). В результате возвращается индексный массив вида `[key, value]`.  
`{ a: ?a, "b" => 1 }.shift # -> [ :a, "a" ]`

`.delete(key) # -> object`

`(key) { |key| } # -> object`

Используется для удаление заданного элемента (изменяется значение объекта). В результате возвращается значение ключа. Если ключ не найден, то возвращается значение по умолчанию или результат выполнения необязательного блока.

~~~~~ ruby
  { a: ?a, "b" => 1 }.delete :a # -> "a"
  hash # -> { "b"=>1 }
~~~~~

`.delete_if { |key, value| } # -> self`

Используется для удаления всех элементов с положительным результатом итерации (изменяется значение объекта).  
`{ a: ?a, "b" => 1 }.delete_if { |key| key == ?b } # -> { a: "a" }`

`.reject { |key, value| } # -> hash`

Версия предыдущего метода, не изменяющая значение объекта.  
`{ a: ?a, "b" => 1 }.reject { |key| key == ?b } # -> { a: "a" }`

`.reject! { |key, value| } # -> self || nil`

Версия предыдущего метода, изменяющая значение объекта. Если ни один объект не был удален, то возвращается nil.  
`{ a: ?a, "b" => 1 }.reject! { |key| key == ?c } # -> nil`

`.keep_if { |key, value| } # -> self`

Используется для сохранения только элементов с положительным результатом итерации (изменяется значение объекта).  
`{ a: ?a, "b" => 1 }.keep_if { |key| key == ?b } # -> { "b"=>1 }`

`.select! { |key, value| } # -> self`

Версия предыдущего метода, возвращающая nil, если ни один элемент не был удален.  
`{ a: ?a, "b" => 1 }.select! { |key| key == ?b } # -> { "b"=>1 }`

#### Остальное

`.replace(hash) # -> self`  
Синонимы: `initialize_copy`

Используется для замены значения объекта.  
`{ a: ?a, "b" => 1 }.replace( { } ) # -> { }`

`.invert # -> hash`

Используется для смены ключей и их значений местами.  
`{ a: ?a, "b" => 1 }.invert # -> { "a" => :a, 1 => "b" }`

### Предикаты

`.has_key?(key)`  
Синонимы: `include?, key?, member?`

Проверка наличия ключа.  
`{ a: ?a, "b" => 1 }.has_key? :a # -> true`

`.has_value?(object)`  
Синонимы: `value?`

Проверка наличия значения.  
`{ a: ?a, "b" => 1 }.has_value? :a # -> false`

`.compare_by_identity? # -> bool`

Проверка сравниваются ли все ключи по их объектам-идентификаторам.

`.empty? # -> bool`

Проверка отсутствия элементов.  
`{ a: ?a, "b" => 1 }.empty? # -> false`

### Итераторы

`.each { |key, value| } # -> self`  
Синонимы: `each_pair`

Перебор элементов.

`.each_key { |key| } # -> self` Перебор ключей.

`.each_value { |value| } # -> self` Перебор значений.

### Индексные массивы

`.assoc(key) # -> array`

Используется для получения индексного массива, содержащего найденный элемент. Если ключ не найден, то возвращается nil. Сравнение ключей выполняется с помощью оператора `==`.  
`{ a: ?a, "b" => 1 }.assoc :a # -> [:a, "a"]`

`.rassoc(object) # -> array`

Версия предыдущего методы, выполняющая поиск элемента по значению.
`{ a: ?a, "b" => 1 }.rassoc ?a # -> [:a, "a"]`

`.flatten( deep = 0 ) # -> array`

Используется для получения индексного массива, содержащего элементы ассоциативного. Все вложенные индексные массивы будут извлекаться до заданного уровня.

~~~~~ ruby
  { 1 => "one", 2 => [ [2], ["two"] ], 3 => "three" }.flatten 3
  # -> [1, "one", 2, 2, "two", 3, "three"]
~~~~~

### Остальное

`.compare_by_identity # -> self`

Используется для ограничения доступа к элементам с текстовыми ключами.

~~~~~ ruby
  { a: ?a, "b" => 1 }.compare_by_identity
  # -> { :a => "a", "b" => 1 }

  hash[:a] # -> "a"
  hash["b"] # -> nil
  hash[:b] # -> nil
  hash.key 1 # -> "b"
~~~~~

`.size # -> integer`  
Синонимы: `length`

Количество элементов.  
`{ a: ?a, "b" => 1 }.size # -> 2`

`.default # -> object` Значение по умолчанию.

`.default_proc # -> proc`

Подпрограмма, выполняющаяся по умолчанию (или nil).

`.default=(object) # -> object`

Используется для изменения значения по умолчанию.

`.default = proc # -> proc`

Используется для изменения подпрограммы, выполняющейся по умолчанию.

`.hash # -> integer`

Цифровой код объекта.  
`{ a: ?a, "b" => 1 }.hash # -> -3034512`

`.rehash # -> hash` Используется для обновления цифровых кодов ключей.

## Range (диапазоны)

Диапазоны необходимо ограничивать круглыми скобками. В противном случае метод будет вызван только для конечной границы.

`::new( first, last, include_last = false ) # -> range`

Используется для создания диапазона с переданными границами. Логическая величина влияет на обработку конечной границы.  
`Range.new 1, 5, 0 # -> 1...5`

### Приведение типов

`.inspect # -> string`

Преобразование диапазона в текст, с помощью вызова метода `.inspect` для каждой границы.  
`(1..3).inspect # -> "1..3"`

`.to_s # -> string`
Преобразование диапазон в текст.  
`(1..3).to_s # -> "1..3"`

### Элементы

`.begin # -> object`

Первый элемент диапазона.  
`(1..3).begin # -> 1`

`.end # -> object`

Последний элемент диапазона.  
`(1..3).end # -> 3`

`.last( size = nil ) # -> array`

Последний элемент или последний фрагмент.  
`(1..3).last 2 # -> [ 2, 3 ]`

### Операторы

`.===(object)`  
Синонимы: `cover?, member?, include?`

Проверяка входит ли объект в диапазон.
`(1..3) === 2 # -> true`

### Итераторы

`.each { |object| } # -> self` Перебор элементов с  помощью метода `.succ`.

`.step( step = 1 ) { |object| } # -> self`


Перебор элементов с заданным шагом, либо прибавляя его после каждой итерации, либо используя метод `.succ`.

### Остальное

`.exclude_end? # -> bool`

Проверка входит ли конечная граница в диапазон.  
`(1..3).exclude_end? # -> false`

`.bsearch { |x| } # -> elem [Ruby 2.0]`

Реализация двоичного поиска (метода деления пополам, дихотомии). Используется для нахождения элемента, который отвечает заданному условию за O(log n), где n - это размер диапазона. Алгоритм выполняет поиск элемента, используя дробление диапазона на половины.

Метод реализован как в классическом варианте, так и для использования бисекции.

+ Поиск элемента

  Блок должен возвращать логическую величину для каждого элемента. Диапазон должен содержать значение x, так что:

  + Блок возвращает false для любого элемента меньше чем x.
  + Блок возвращает true для любого элемента, больше или равного x.

  В результате возвращается x или nil.

  ~~~~~ ruby
    ary = [0, 4, 7, 10, 12]
    (0...ary.size).bsearch { |i| ary[i] >= 4 } # -> 1
    (0...ary.size).bsearch { |i| ary[i] >= 6 } # -> 2
    (0...ary.size).bsearch { |i| ary[i] >= 8 } # -> 3
    (0...ary.size).bsearch { |i| ary[i] >= 100 } # -> nil

    (0.0...Float::INFINITY).bsearch { |x| Math.log(x) >= 0 } # -> 1.0
  ~~~~~

+ Метод бисекции (метод деления отрезка пополам)

  Простейший численный метод для решения нелинейных уравнений вида `F(x) = 0`.

  Блок должен возвращать число для каждого элемента. Диапазон должен содержать элементы x и y (`x <= y`), так что:

  + Блок возвращает положительное число для элементов меньше чем x.
  + Блок возвращает ноль для элементов из диапазона `x...v`.
  + Блок возвращает отрицательное число для элементов больше иди равным y.

  В результате возвращается любой из элементов из диапазона `x...y`. Если нет элементов, отвечающих условию, возвращается nil.

  ~~~~~ ruby
    ary = [0, 100, 100, 100, 200]
    (0..4).bsearch { |i| 100 - ary[i] } # -> 1, 2 или 3
    (0..4).bsearch { |i| 300 - ary[i] } # -> nil
    (0..4).bsearch { |i|  50 - ary[i] } # -> nil
  ~~~~~

`.hash # -> integer`

Цифровой код объекта.
`(1..3).hash # -> -337569967`

## Enumerator (перечни)

Перечни - это составные объекты, содержащие группу элементов и о методе, вызов которого привел к их группировке. Индексация элементов начинается с нуля.

Перечень всех элементов может быть получен с помощью итераторов, которым не был передан блок.

`::new( object, method, *arg ) # -> enum`

`{ |enum| } # -> enum`

Используется для создания перечня. Результат также может быть передан в блок. В теле блока предоставляется возможность добавлять элементы в перечень с помощью выражения `enum << object` (как синоним для yield). Тело блока будет выполняться в момент использования перечня.

~~~~~ ruby
  Enumerator.new( [1, 2, ?R], :delete_at, 2 )
  # -> #<Enumerator: [1, 2, "R"]:delete_at(2)>

  Enumerator.new { |enum| enum << 3 }
  # -> #<Enumerator: <Enumerator::Generator:0x87378e8>:each>
~~~~~

`.enum_for( method = :each, *arg ) # -> enum`  
Синонимы: `to_enum`

Используется для создания перечня элементов текущего составного объекта.  
`[1, 2, ?R].enum_for # -> #<Enumerator: [1, 2, "R"]:each>`

### Приведение типов

`.inspect # -> string`

Используется для получения информации об объекте.

~~~~~ ruby
  Enumerate.new( [1, 2, ?R], :delete_at, 2 ).inspect
  # -> "#<Enumerator: [1, 2, \"R\"]:delete_at(2)>"
~~~~~

### Элементы перечня

`.next # -> object`

Используется для последовательного доступа к элементам перечня. Достижение конца перечня считается исключением `StopIteration`.

`.next_values # -> array`

Версия предыдущего метода, возвращающая элементы в индексном массиве. Этот метод может быть использован для различия между инструкциями yield и yield nil.

`.peek # -> object`

Используется для получения следующего элемента перечня.  Достижение конца перечня считается исключением `StopIteration`.

`.peek_values # -> array`

Версия предыдущего метода, возвращающая элементы в индексном массиве. Этот метод может быть использован для различия между инструкциями yield и yield nil.

`.rewind # -> enum`

Используется для обнуления позиции последнего извлеченного элемента.

### Итераторы

`.each( start = 0 ) { |object| } # -> self` Перебор элементов.

`.with_index( start = 0 ) { |object, index| } # -> self`

Перебор элементов с их индексами.

`.with_object(object) { |object2, object| } # -> object`

Перебор элементов вместе с дополнительным объектом.

### Остальное

`.feed( object = nil ) # -> nil`

Используется для изменения результата следующей итерации перечня. При вызове без аргументов, использование инструкции yield возвращает nil.

`.size # -> integer [Ruby 2.0]`

Используется для получения размера перечня без вычисления его элементов. Если вычисление невозможно, то возвращается nil.

~~~~~ ruby
  (1..100).to_a.permutation(4).size # -> 94109400
  loop.size # -> Float::INFINITY
  (1..100).drop_while.size # -> nil
~~~~

[](lazy)
### Отложенные вычисления (Enumerator::Lazy)

Класс расширяет понятие перечня (наследует Enemerator).

Во второй версии добавлена возможность откладывать итерирование элементов составного объекта (возможно бесконечного) до того момента как они потребуются.

К сожалению отложенные вычисления обычно медленнее чем обычные, поэтому их применение должно быть оправдано.

`::new( enum, size = nil ) { | yielder, *values | } # -> a_lazy_enum`

Используется для создания объекта. Когда будет вычисляться содержимое перечня, элементы составного объекта будут переданы в блок и смогут быть возвращены в перечень с помощью первого параметра блока.

~~~~~ ruby
  # Принудительное вычисление.
  module Enumerable
    def filter_map(&block)
      map(&block).compact
    end
  end

  # Отложенное вычисление.
  class Enumerator::Lazy
    def filter_map
      Lazy.new(self) do | yielder, *values |
        result = yield *values
        yielder << result if result
      end
    end
  end

  (1..Float::INFINITY).lazy.filter_map{ |i| i*i if i.even? }.first(5)
  # -> [ 4, 16, 36, 64, 100 ]
~~~~~

`.lazy # -> a_lazy_enum`

Используется для создания перечня, позволяющего выполнять отложенные вычисления.

~~~~~ ruby
  [1,2,3].lazy # -> #<Enumerator::Lazy: [1, 2, 3]>
~~~~~

#### Методы

`.force # -> array`  
Синонимы: `to_a`

Используется для принудительного вычисления элементов.

`.collect_concat { |object| } # -> a_lazy_enum`  
Синонимы: `flat_map`

Используется для получения нового перечня, содержащего результаты итерации всех элементов текущего.

~~~~~ ruby
  [ 'foo', 'bar' ].lazy.flat_map { |i| i.each_char.lazy }.force
  # -> [ 'f', 'o', 'o', 'b', 'a', 'r' ]
~~~~~

Результаты итерации будут объединяться в том случае, если они относятся к перечням (отвечают на вызовы методов `.each` и `.force`) или массивам (отвечают на вызов метода `.to_ary`).

~~~~~ ruby
  [ {a:1}, {b:2} ].lazy.flat_map { |i| i }.force
  #=> [ {a:1}, {b:2} ]
~~~~~

`.enum_for( method = :each, *args ) # -> a_lazy_enum`

`( method = :each, *args ) { |*args| } # -> a_lazy_enum`  
Синонимы: `to_enum`

Аналогично соответствующему методу из модуля Kernel. Используется для того, чтобы методы из модуля Enumerable могли возвращать новый вид перечней, если вызываются для объектов подобного типа.

~~~~~ ruby
  r = 1..Float::INFINITY

  # Принудительные вычисления.
  r.repeat(2).first(5) # -> [ 1, 1, 2, 2, 3 ]
  r.repeat(2).class # -> Enumerator
  r.repeat(2).map{ |n| n ** 2 }.first(5) # -> бесконечный цикл!

  # Отложенные вычисления.
  r.lazy.repeat(2).class # -> Enumerator::Lazy
  r.lazy.repeat(2).map{ |n| n ** 2 }.first(5) # -> [ 1, 1, 4, 4, 9 ]
~~~~~

#### Применение

+ Итерирование бесконечных объектов;
+ Работа с большими файлами.

~~~~~ ruby
  lines = File.foreach('a_very_large_file')
              .lazy # чтение только необходимой части.
              .select { |line| line.length < 10 }
              .map(&:chomp)
              .each_slice(3)
              .map { |lines| lines.join(';').downcase }
              .take_while { |line| line.length > 20 }

  # Чтение первых трёх строк файла или
  # до тех пор пока длина строки не превысит 20 символов.
  lines.first(3)

  lines.to_a # или...
  lines.force # чтение файла
  lines.each { |elem| puts elem } # и запись каждой строки.
~~~~~

## Enumerable

Модуль содержит методы для работы с составными объектами, реализующими перебор своих элементов с помощью метода `.each`.

Также для некоторых методов может понадобиться определение оператора `<=>`.

Ассоциативные массивы преобразуются в индексные с помощью метода `.to_a`.

### Приведение типов

`.to_a # -> array`  
Синонимы: `entry`

Преобразование в индексный массив.

### Элементы

`.first( size = nil ) # -> object`

Используется для получения первого элемента или начального фрагмента. Если методу передается ноль, то возвращается пустой массив.  
`[1, 2, 3].first 2 # -> [1, 2]`

`.take(size) # -> array`

Используется для получения фрагмента заданного размера. Если методу передается ноль, то возвращается пустой массив.  
`[1, 2, 3].take 2 # -> [1, 2]`

`.drop(size) # -> array`

Используется для удаления фрагмента заданного размера.  
`[1, 2, 3].drop 2 # -> [3]`

### Сортировка и группировка

`.sort # -> array`

`{ |first, second| } # -> array`

Используется для сортировки элементов либо с помощью оператора `<=>`, либо на основе результатов итерации.  
`{ a: 1, b: 2, c: 3 }.sort # -> [ [:a, 1], [:b, 2], [:c, 3] ]`

`.sort_by { |first, second| } # -> array`

Используется для сортировки в восходящем порядке на основе результатов итерации.

~~~~~ ruby
  { a: 1, b: 2, c: 3 }.sort_by { |array| -array[1] }
  # -> [ [:c, 3], [:b, 2], [:a, 1] ]
~~~~~

`.group_by { |object| } # -> hash`

Используется для группировки элементов на основе результата итерации.  
`[1, 2].group_by { |elem| elem > 4 } # -> { false => [1, 2] }`

`.zip(*object) # -> array`

`(*object) { |array| } # -> nil`

Используется для группировки элементов с одинаковыми индексами. Группы могут передаваться в необязательный блок.

Количество групп равно размеру объекта, для которого метод был вызван. Остальные объекты при необходимости дополняются элементами, ссылающимися на nil.

~~~~~ ruby
  { a: 1, b: 2 }.zip [1, 2], [1]
  # -> [ [ [:a, 1], 1, 1 ], [ [:b, 2], 2, nil ] ]
~~~~~

`.chunk { |object| } # -> enum`

`(buffer) { |object, buffer| } # -> enum`

Используется для группировки элементов на основе результатов итерации.

Результат выполнения блока для дальнейшего использования может быть сохранен с помощью дополнительного аргумента.

Блок может возвращать специальные объекты:

+ *nil* или *:_* - игнорировать элемент;  
  *:_alone* - элемент будет единственным в группе.

`.slice_before(object) # -> enum`

`{ |object| } # -> enum`

`(buffer  { |object, buffer| } # -> enum`

Используется для группировки элементов. Новая группа начинается с элемента равного переданному аргументу (сравнение выполняется с помощью оператора `===`), или c положительным результатом итерации.

Первый элемент игнорируется.

В перечне каждая группа объектов сохраняется в виде индексного массива.

### Поиск элементов

`.count( object = nil ) # -> integer`

`{ |object| } # -> integer`

Используется для получения количества элементов, либо равных переданному аргументу, либо с положительным результатом итерации. При вызове без аргументов возвращает количество элементов.  
`[ 1, 2, 3 ].count { |elem| elem < 4 } # -> 3`

`.grep(object) # -> array`

`(object) { |object| } # -> array`

Используется для получения всех элементов, равных переданному аргументу (сравнение выполняется с помощью оператора `===`).

При получении блока вместо элементов возвращается результат их итерации.
`[ 1, 2, 3 ].grep(2) { |elem| elem > 4 } # -> [false]`

`.find_all { |object| } # -> array`  
Синонимы: `select`

Используется для получения всех элементов с положительным результатом итерации.  
`[1, 2, 3].find_all { |elem| elem > 4 } # -> [ ]`

`.reject { |object| } # -> array`

Используется для удаления всех элементов с положительным результатом итерации.  
`[1, 2, 3].reject { |elem| elem > 4 } # -> [1, 2, 3]`

`.partition { |object| } # -> array`

Используется для получения фрагментов с различными логическими результатами итерации.  
`[1, 2, 3].partition { |elem| elem > 2 } # -> [ [3], [1, 2] ]`

`.detect( default = nil ) { |elem| } # -> object`  
Синонимы: `find`

Используется для поиска первого элемента с положительным результатом итерации. Если искомый элемент не найден, то возвращается либо nil, либо значение по умолчанию.  
`[1, 2, 3].detect { |elem| elem > 4 } # -> nil`

`.find_index( object = nil ) # -> index`

`{ |object| } # -> index`

Используется для поиска индекса первого элемента, либо равного переданному аргументу, либо с положительным результатом итерации. Если элемент не найден, то возвращается nil.  
`[1, 2, 3].find_index { |elem| elem > 4 } # -> nil`

### Сравнение элементов

Сравнение выполняется с помощью оператора `<=>`.

`.min # -> object`

Наименьший элемент.  
`[1, 2, 3].min # -> 1`

`.max # -> object`

Наибольший элемент.  
`[1, 2, 3].max # -> 3`

`.minmax # -> array`

Наименьший и наибольший элементы.  
`[1, 2, 3].minmax # -> [1, 3]`

`.min_by { |object| } # -> object`

Элемент с наименьшим результатом итерации.  
`[1, 2, 3].min_by { |elem| -elem } # -> 3`

`.max_by { |object| } # -> object`

Элемент с наибольшим результатом итерации.  
`[1, 2, 3].max_by { |elem| -elem } # -> 1`

`.minmax_by { |object| } # -> array`

Элементы с наименьшим и наибольшим результатами итерации.  
`[1, 2, 3].minmax_by { |elem| -elem } # -> [3, 1]`

### Предикаты

`.include?(object)`  
Синонимы: `member?`

Проверка наличия элемента, равного переданному аргументу (сравнение выполняется с помощью оператора `==`).  
`[1, 2, 3].include? 4  # -> false`

`.all? { |object| }`

Проверка отсутствия элементов с отрицательным результатом итерации. При отсутствии блока проверяется каждый элемент.  
`[1, 2, 3].all? { |elem| elem < 4 } # -> true`

`.any? { |object| }`

Проверка наличия хотя бы одного элемента с положительным результатом итерации. При отсутствии блока проверяется каждый элемент.  
`[1, 2, 3].any? { |elem| elem < 4 } # -> true`

`.one? { |object| }`

Проверка наличия только одного элемента с положительным результатом итерации. При отсутствии блока проверяется каждый элемент.  
`[1, 2, 3].one? { |elem| elem < 4 } # -> false`

`.none? { |object| }`

Проверка отсутствия элементов с положительным результатом итерации. При отсутствии блока проверяется каждый элемент.  
`[1, 2, 3].none? { |elem| elem < 4 } # -> false`

### Итераторы

`.collect { |object| } # -> array`  
Синонимы: `map, collect_concat, flat_map`

Перебор элементов с сохранением результатов итерации.

~~~~~ ruby
  [1, 2, 3].collect { |elem| elem < 4 } # -> [true, true, true]
  (1..3).collect(&:next) * ?| # -> "2|3|4"
~~~~~

`.reverse_each( *arg ) { |object| } # -> self`

Перебор элементов в обратном порядке.

`.each_with_index { |object, index| } # -> self`

Перебор элементов вместе с индексами.

`.each_with_object(object) { |elem, object| } # -> object`

Перебор элементов вместе с переданным объектом.

`.each_slice(size) { |array| } # -> nil`

Перебор фрагментов заданного размера.

`.each_cons(size) { |array| } # -> nil`

Перебор фрагментов заданного размера. После каждой итерации из начала фрагмента будет удаляется элемент, а в конец будет добавлен следующий элемент составного объекта.

`.each_entry { |object| } # -> nil`

Перебор элементов. Несколько объектов, переданных инструкции yield в теле метода `.each`, сохраняются в индексном массиве.

### Циклы

`.drop_while { |object| } # -> array`

Выполнение блока для всех элементов кроме первого вплоть до получения отрицательного результата итерации. Возвращаются элементы, итерация которых не выполнялась. Иными словами элементы удаляются пока результат итерации положителен.
`[1, 2, 3].drop_while { |elem| elem < 4 } # -> [ ]`

`.take_while { |object| } # -> array`

Выполнение блока для всех элементов кроме первого вплоть до получения отрицательного результата итерации. Возвращаются элементы, итерация которых выполнялась. Иными словами элементы сохраняются пока результат итерации положителен.  
`[1, 2, 3].take_while { |elem| elem < 4 } # -> [1, 2, 3]`

`.cycle( step = nil ) { |object| } # -> nil`

Выполнение блока для всех элементов в бесконечном цикле. Выполнение может быть остановлено с помощью инструкций или ограничения количества циклов. Если методу передано отрицательное число, то вызов метода завершается до выполнения.

### Остальное

`.lazy # -> a_lazy_enumerator [Ruby 2.0]`

Используется для создания перечня, позволяющего выполнять [отложенные вычисления](lazy).

`.inject(method) # -> object`

`(first, method) # -> object`

`(first = nil) { |buffer, first| } # -> buffer`  
Синонимы: `reduce`

Используется для объединения элементов либо с помощью указанного метода, либо передавая результат каждой итерации первому параметру блока. Выполнение начинается с первого элемента или с дополнительно переданного аргумента.

Часто используется в функциональном стиле программирования и известно как "свертка".  
`[1, 2, 3].inject( 100, :+ ) # -> 106`