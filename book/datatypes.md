## Элементарные типы данных

Каждый язык программирования поддерживает один или несколько элементарных типов данных. Поддержка означает, что интерпретатор автоматически определит тип данных, основываясь на существующих лексических правилах.

К простым типам данных относятся числа, текст, логические величины, идентификаторы и регулярные выражения. Такие типы данных используются как базовые блоки для построения других типов.

К составным типам относятся индексные и ассоциативные массивы, а такеж диапазоны. Такие типы данных используются для группировки элементов (данных) и работы с полученной группой.


### Числа (Numeric)

#### Целые числа (Integer)

~~~~~ruby
1000
1_000  # -> 1000
0x4AF  # -> 1199
0b0111 # -> 7
+1
-1
~~~~~

Лексема числа - это обычный набор цифр.

Для разделения разрядов может использоваться символ подчеркивания (`_`), который будет игнорироваться интерпретатором (`1_000_000`). Однако этот знак нельзя использовать в начале или в конце лексемы.

Также существуют приставки, определяющие систему счисления.

+ По умолчанию, все числа обрабатываются в десятичной системе счисления. Результат любых вычислений также преобразуется в десятичную систему;

+ Числа, начинающиеся с приставки 0x или 0X, обрабатываются в шестнадцатеричной системе счисления;

+ Числа, начинающиеся с приставки 0b или 0B, обрабатываются в двоичной системе счисления.

Для записи отрицательных чисел используется знак "минус" (`-`).

Для записи положительных чисел используется знак "плюс" (`+`).  По умолчанию все числа обрабатываются как положительные.

#### Десятичные дроби (Float)

~~~~~ruby
123.051
123e-10
1_000.543
-1000.543
+1000.543
~~~~~

Лексема десятичной дроби - это группа цифр, разделенных десятичной точкой на две части: целую и дробную (`123.051`).

Так же можно использовать научную или экспоненциальную нотацию. При этом после числа записывается символ экспоненты (e или Е), после которого следует отрицательное или положительное число, обозначающее показатель степени 10 (`123е-10` - соответствует `$123 * 10^{-10}$`).

При записи десятичных дробей для разделения разрядов может использоваться символ подчеркивания (`_`), который будет игнорироваться интерпретатором.

Для записи отрицательных чисел используется знак "минус" (`-`).

Для записи положительных чисел используется знак "плюс" (`+`).  По умолчанию все числа обрабатываются как положительные.

### Текст (String)

~~~~~ruby
'Ruby'

%q(Ru#{1}by) # -> "Ru\#{1}by"

<<-'DOC'
  Ru#{1}by
DOC
# -> "  Ru\#{1}by\n"
~~~~~

~~~~~ruby
"Ruby"

%Q(Ru#{1}by) # -> "Ruby"
%(Ru#{1}by)  # -> "Ruby"

<<-DOC
  Ru#{1}by
DOC
# -> "  Ru1by\n"
~~~~~

~~~~~ruby
?A # -> "A"
~~~~~

Текст - это набор из одного или более символов. Символ - это любой отображаемый на экране знак.

~~~~~ note
Обычно этот тип данных называют строками. Несмотря на то, что текст может содержать символ перевода строки, он все равно рассматривается как одна большая строка. Я решил использовать термин "текст" чтобы избежать путаницы между понятиями строки кода (line), строки как объекта (string) и строки текста. В английском языке для каждой из строк существует отдельный термин, который при переводе на русский теряет смысловую нагрузку.
~~~~~

#### Простой текст

Простой текст - это группа символов, ограниченная одиночными кавычками (`'Ruby'`). Обрабатывается в том виде, в котором записан с учетом минимального набора спецсимволов (называемых также управляющими или экранированными последовательностями). Спецсимвол - это группа из одного или более символов, теряющих своё индивидуальное значение, одновременно с приобретением этой группой нового значения.

##### Спецсимволы:

`\'` - соответствует символу одиночной кавычки;

`\\\\` - соответствует символу обратной косой черты.

*****

#### Составной текст

Составной текст - это группа символов, ограниченная двойными кавычками (`"Ruby"`). Обрабатывается с учетом полного набора спецсимволов и поддержкой интерполяции. В составном тексте также разрешается использовать другие парные символы двойных кавычек (`""""`).

Интерполяция - это выполнение фрагментов кода `"#{выражение}"` и замена их на результат выполнения. Так, вместо `"#{1+2}"` интерпретатор будет использовать текст "3".

##### Спецсимволы:

`\*` - соответствует любому символу на месте *, который необходимо сохранить в тексте. Используется для экранирования символов. Поэтому спецсимволы также называют экранированными последовательностями - все они начинаются с обратной косой черты;

`\b` - удаление предыдущего символа;

`\r` - возврат указателя курсора на начало строки. Запись следующего символа удалит все предыдущие (символ возврата каретки). Спецсимвол используется для вставки новой строки вместо предыдущей. Это полезно для замены строк в различных программах (например отображение хода выполнения программы в терминале).

`\n` - перевод указателя курсора на начало новой строки (символ перевода строки). Для операционной системы Windows в качестве символа перевода строки используется спецсимвол `\r\n`.

`\t` - отступ, т.е. перевод указателя курсора вправо (табуляция);

`\...` - соответствует символу, с указанной кодовой позицией из трех цифр в восьмеричной системе счисления;

`\\..` - соответствует `\0..`;

`\\.` - соответствует `\00.`;

`\x..` - соответствует символу, с указанной кодовой позицией;

`\x.` - соответствует `\x0.`;

`\u....` - соответствует символу, с указанной кодовой позицией в стандарте Юникод;

`\u{.}` – соответствует группе символов, с указанными кодовыми позициями в стандарте Юникод.

*****

Текст также может быть записан между двумя произвольными разделителями с использованием приставок `%q` или `%Q` (`%`). При использовании приставки `%q` текст будет распознаваться как простой, а при использовании приставки `%Q` (`%`) - как составной.

#### Документы

Документы - это большие блоки текста, с многочисленными знаками препинания.

Лексема документа начинается с символов `<<` или `<<-`. За ними следует группа символов, которая будет служить границей текста.

Тело документа (текст) начинается со следующей строки. Объект создается, когда на отдельной строке будет использован разделитель. После создания объекта интерпретатор продолжит обработку кода с того места, на котором встретил начало лексемы.

+ Когда лексема начинается с `<<`, пробелы между началом строки и конечным разделителем не допускаются. Пробелы после конечного разделителя не допускаются никогда;

+ Когда начальный разделитель не ограничен кавычками, лексема распознается как составной текст. Чтобы сохранить простой текст начальный разделитель ограничивают одинарными кавычками. Кавычки также позволяют использовать пробелы внутри разделителя.

#### Одиночный символ

Одиночный символ - это текст, начинающийся со знака вопроса (`?A`).

При использовании лексемы распознаются некоторые спецсимволы, в основном относящиеся к способам записи символов с помощью кодовых позиций.

### Логические величины

~~~~~ ruby
true  # -> истина
false # -> ложь
nil   # -> отсутствие данных
~~~~~

Логические величины используются для булевой алгебры, проверки различных условий или сравнения объектов.

При использовании в выражениях лексемы false и nil имеют логическое значение false, а все остальные - логическое значение true.

Иногда также говорят о положительном результате (логическое значение true) и отрицательном (логическое значение false).

### Текстовые идентификаторы (Symbol)

~~~~~ruby
:green
%s(green) # -> :green
~~~~

Довольно часто для управления программой используются небольшие группы символов. Из-за особенностей реализации, использование для этого текста снижает скорость выполнения программы. Вместо этого рекомендуется использовать текстовые идентификаторы.

Лексема текстового идентификатора - это группа символов, следующая за двоеточием. Также текстовый идентификатор может быть записан между двумя произвольными разделителями, с использованием приставки `%s`.

~~~~~ note
Почему использование текстовых идентификаторов предпочтительней?

Для каждого идентификатора, хранится также цифровой код, вычисленный на основе используемых символов. При повторном использовании той же группы символов, вместо создания нового идентификатора, по цифровому коду будет найден уже существующий (в случае с текстом - всегда создаются новые данные). Использование цифровых кодов также ускоряет поиск и сравнение тектсовых идентификаторов.

Однажды созданный текстовый идентификатор будет существовать до закрытия программы, поэтому необходимо осторожно подходить к их использованию и делать это только по назначению (с целью управления процессом выполнения программы). Динамическое создание множества идентификаторов увеличивает количество памяти, занимаемой программой.
~~~~~

### Регулярные выражения (Regexp)

~~~~ruby
/Ruby/i
%r(Ruby)i
~~~~

Полный синтаксис регулярных выражений описывается в [приложении](appregexp).

Регулярные выражения - это мощный инструмент для поиска по тексту. С помощью регулярных выражений составляются образцы, на основе которых выполняется поиск.

Лексема регулярного выражения - это группа символов (называемая телом регулярного выражения), ограниченная двумя косыми чертами (slash - /). После конечного разделителя может быть использован необязательный модификатор, влияющий на механизм поиска.

Тело регулярного выражения также может быть записано между двумя произвольными разделителями с использованием приставки `%r`. Модификаторы в этом случае записываются после конечного разделителя.

Тело регулярного выражения обрабатывается как составной текст. Одиночные символы, не относящиеся к спецсимволам соответствуют их аналогам в тексте.

Поиск совпадений выполняется последовательно по каждому символу, слева направо.

### Индексные массивы (Array)

~~~~~ruby
[1, "Ruby", ?\u0048]
%W( Первый Второй Третий ) # -> [ "Первый", "Второй", "Третий" ]
%I( category klass ) # -> [:category, :klass]
~~~~~

Индексный массив (или просто массив) - это составной тип данных, содержащий упорядоченную группу элементов и позволяющий получить доступ к элементу, если известна его позиция (индекс элемента). Элементами массива могут быть любые данные (даже другие массивы).

С точки зрения правил, индексные массивы - это группа данных между двумя квадратными скобками. Сами данные при этом разделяются запятыми.

Существует также специальный синтаксис записи массивов, в качестве элементов которых выступают короткие отрывки текста (состоящие из одного слова и не содержащие пробелов). Такие массивы могут быть записаны в виде группы элементов между двумя произвольными разделителями с использованием приставок `%w` или `%W`. Сами элементы при этом разделяются пробелами.

При использовании приставки `%w` элементы массива будут рассматриваться как простой текст, а при использовании приставки `%W` - как составной.

Существует также специальный синтаксис записи массивов, в качестве элементов которых выступают текстовые идентификаторы. Такие массивы могут быть записаны в виде группы элементов между двумя произвольными разделителями с использованием приставок `%i` или `%I`. Сами элементы при этом разделяются пробелами.

При использовании приставки `%i` элементы массива будут рассматриваться как простой текст, а при использовании приставки `%I` - как составной.

### Ассоциативные массивы (Hash)

~~~~~ruby
{ "black" => "черный", "white" => "белый" }
{ :black  => "черный", :white  => "белый" }
{ black: "черный", white: "белый" }
~~~~~

Ассоциативный массив - это составной объект, содержащий упорядоченную группу элементов (каждый из которых представляет собой пару ключ/значение) и позволяющий получить доступ к значению, если известен его ключ (ключ ассоциируется с объектом).

В ассоциативном массиве можно хранить любые данные (даже другие массивы).

С точки зрения синтаксиса, ассоциативные массивы - это группа парных элементов ключ/значение между двумя фигурными скобками. Ключи от значений отделяются символами `=>`. Сами элементы при этом разделяются запятыми.

Один из наиболее распространенных способов использования текстовых идентификаторов - в качестве ключей ассоциативного массива. При этом ассоциативный массив записывают в коде программы, отделяя ключи от значений двоеточием (при этом двоеточие перед ключом не используется).

### Диапазоны (Range)

~~~~~ruby
1..3  # -> содержит числа 1, 2, 3
1...3 # -> содержит числа 1 и 2
a..c  # -> содержит буквы a, b, c
~~~~~

Диапазон - это составной тип данных, содержащий упорядоченный набор элементов, располагающихся между заданными границами.

С точки зрения правил, диапазоны - это два однотипных элемента, разделенные двумя или тремя точками. При использовании двух точек в диапазон включается конечная граница, а при использовании трех - нет.
