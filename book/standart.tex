\chapter{Стандартные типы данных}

Каждый язык программирование поддерживает один или несколько встроенных типов данных. Экземпляры стандартных типов создаются без явного указания класса создаваемого объекта - он вычисляется автоматически на основе существующих лексических правил.

\section{Элементарные типы данных}

К элементарным типам данных относятся числа, текст, логические величины, объекты-идентификаторы и регулярные выражения. Элементарные типы данных - это базовые блоки для построения других типов данных. На их основе создаются все остальные классы.

\subsection{Числа}

Числа в Ruby описываются абстрактным классом Numeric и его подклассами.

\paragraph*{Целые числа:} абстрактный класс Integer и его подклассы Fixnum и Bignum.

Целые числа, занимающие в памяти не более 31-го бита, относятся к классу Fixnum. Целые числа, превышающие этот размер, относятся к классу Bignum. Преобразование между типами чисел происходит автоматически.

Лексема для чисел - это обычный набор цифр (1289). Для разделения разрядов может использоваться символ подчеркивания (\mono{_}), который будет игнорироваться интерпретатором. Однако этот знак нельзя использовать в начале или в конце лексемы (\verb!1_000_000! - соответствует одному миллиону). 

\itemtitle{Системы счисления:}
\begin{itemize}
  \item По умолчанию, все числа обрабатываются в десятичной системе счисления. Результат любых вычислений также преобразуется в десятичную систему;

  \item Числа, начинающиеся с приставки 0x или 0X, обрабатываются в шестнадцатеричной системе счисления (0х4AF);

  \item Числа, начинающиеся с приставки 0b или 0B, обрабатываются в двоичной системе счисления (0b0111).
\end{itemize}

Для записи отрицательных чисел используется знак "минус" ($-$). 

Для записи положительных чисел используется знак "плюс" ($+$).  По умолчанию все числа обрабатываются как положительные.

\paragraph*{Десятичные дроби:} класс Float.

Лексема для десятичных дробей - это группа цифр, разделенных десятичной точкой на две части: целую и дробную ($123.051$). Так же можно использовать научную или экспоненциальную нотацию. При этом после числа записывается символ экспоненты (e или Е), после которого следует отрицательное или положительное число, обозначающее показатель степени 10 (\verb!123е-10! - соответствует $123 * 10^{-10}$). 

При записи десятичных дробей для разделения разрядов может использоваться символ подчеркивания (\mono{_}), который будет игнорироваться интерпретатором.

\subsection{Текст}

Текст - это набор из одного или более символов. Символ - это любой отображаемый на экране знак. Работа с текстом в Ruby описывается классом String.
\begin{note}
  Обычно этот тип данных называют строками. Несмотря на то, что текст может содержать символ перевода строки, он все равно рассматривается как одна большая строка. Я решил использовать термин "текст" чтобы избежать путаницы между понятими строки кода (line), строки как объекта (string) и строки текста. В английском языке для каждой из строк существует отдельный термин, который при переводе на русский теряет смысловую нагрузку.
\end{note} 
  
\paragraph*{Простой текст:} группа символов, ограниченная одиночными кавычками (\verb!'Ruby'!).  

Простой текст обрабатывается в том виде, в котором записан. 

В простом тексте также распознается минимальный набор спецсимволов (называемых также управляющими или экранированными поселдовательностями). Спецсимвол - это группа из одного или более символов, теряющих своё индивидуальное значение, одновременно с приобретением этой группой нового значения. 

\begin{keylist}{Спецсимволы:}  
  \firstkey{\textbackslash '} - соответствует символу одиночной кавычки;
  
  \key{\textbackslash} - соответствует символу обратной косой черты.
\end{keylist}
  
\paragraph*{Составной текст:} группа символов, ограниченная двойными кавычками (\verb!"Ruby"!). 

Составной текст обрабатывается интерпретатором с распознаванием полного набора эмблем и поддержкой интерполяции.

Интерполяция - это выполнение фраментов кода \verb!#{выражение}! и замена их на результат выполнения выражения (\verb!"#{1+2}"! - соответствует тексту "3"). 

В составном тексте также разрешается использовать другие парные символы двойных кавычек.

\begin{keylist}{Спецсимволы (каждый спецсимвол также определен в кодовой таблице ASCII):}  
  \firstkey{\textbackslash *} - соответствует любому символу на месте *, который необходимо сохранить в тексте. Используется для экранирования символов. Поэтому спецсимволы также называют экранированными последовательностями - все они начинаются с обратной косой черты;
  
  \key{\textbackslash b} -  спецсимвол удаляет предшествующий символ;
  
  \key{\textbackslash r} - спецсимвол возвращает указатель курсора на начало строки, запись следующего символа удалит все предыдущие (символ возврата каретки). Спецсимвол используется для вставки новой строки вместо предыдущей. Это полезно для замены строк в различных программах (например создание прогресс бара в терминале).
  
  \key{\textbackslash n} - спецсимвол переводит указатель курсора на начало новой строки (символ перевода строки). Для операционной системы Windows в качестве символа перевода строки используется спецсимвол \verb!\r\n!.
  
  \key{\textbackslash t} - спецсимвол переводит указатель курсора вправо, создавая отступ (табуляцию);
  
  \key{\textbackslash ***} - соответствует символу, с указанной кодовой позицией из трех цифр в восьмеричной системе счисления;
  
  \key{\textbackslash **} - соответствует \verb!\0**!;
  
  \key{\textbackslash *} - соответствует \verb!\00*!;
  
  \key{\textbackslash x**} - соответствует символу, соотвествующему переданному байту;
  
  \key{\textbackslash x*} - соответствует \verb!\0*!;
  
  \key{\textbackslash u****} - соответствует символу, с указанной кодовой позицией в стандарте Юникод;
  
  \key{\textbackslash u\{*\}} – соответствует тексту, символы которого соответсвуют указанным кодовым позициям в стандарте Юникод.
\end{keylist}

\paragraph*{Специальная форма записи:} приставки \verb!%q! или \verb!%Q!.

Текст также может быть записан между двумя произвольными разделителями с использованием приставок \verb!%q! или \verb!%Q!. Разделитель – это символ или группа символов, которая служит границами текста. При использовании приставки \verb!%q! текст будет распознаваться как простой, а при использовании приставки \verb!%Q! - как составной (\verb!Q(Ruby)! - соответствует тексту "Ruby"). Вместо приставки \verb!%Q!  также можно использовать только знак процента (\verb!%(Ruby)!).

\paragraph*{Документы:} большие блоки текста, с многочисленными знаками препинания. 

Лексема документа начинается с символов \verb!<<! или \verb!<<-!. За ними следует группа символов, которая будет служить границой текста. 

Тело документа (текст) начинается со следующей строки. Объект создается, когда на отдельной строке будет использован разделитель. После создания объекта интерпретатор продолжит обработку кода с того места, на котором встретил начало лексемы (\verb!<<!). 

\begin{itemize}
  \item Если лексема начинается с \verb!<<!, то пробелы между началом строки и конечным разделителем не допускаются. Пробелы после конечного разделителя не допускаются никогда;

  \item Если начальный разделитель не ограничен кавычками, то лексема распознается как составной текст. Чтобы сохранить простой текст начальный разделитель ограничивают одинарными кавычками. Кавычки также позволяют использовать пробелы внутри разделителя (в данном случае в качестве разделителя будет выступать объект).
\end{itemize}
\begin{verbatim}
  <<- 'DOC'
    Здесь записан простой текст.
  DOC
  # -> 'Здесь записан простой текст'
\end{verbatim}

\paragraph*{Одиночные символы:} символ, начинающийся со знака вопроса ?.

При использовании лексемы распознаются некоторые спецсимволы, в основном относящиеся к способам записи символов с помощью кодовых позиций (\verb!?A! – соответствует тексту 'A').

\subsection{Логические величины}

Логические величины используются для булевой алгебры, проверки различных условий или сравнении объектов.

\begin{keylist}{Список лексем:}
  
  \firstkey{Истина:} true ссылается на единственный экземпляр класса TrueClass;
  
  \key{Ложь:} false ссылается на единственный экземпляр класса FalseClass;
  
  \key{Отсутствие:} nil ссылается на единственный экземпляр класса NilClass. Она используется в том случае, если необходимо представить отсутствие объекта, подходящего под заданные условия.
\end{keylist}

При использовании в выражениях лексемы false и nil имеют логическое значение false, а все остальные объекты - логическое значение true.

\subsection{Объекты-идентификаторы}

Довольно часто для управления программой используются небольшие группы символов (слова). Из-за особенностей реализации использование для этого текстовых объектов снижает скорость выполнения программы. Вместо этого рекомендуется использовать экземпляры класса Symbol.

Лексема объекта-идентификатора - это группа символов, следующая за двоеточием (\verb!:green!). Также объект-идентификатор может быть записан между двумя произвольными разделителями, с использованием приставок \verb!%s! или \verb!%S!. При использовании приставки \verb!%s! группа символов распознается как простой текст, а при использовании \verb!%S! - как составной. 
(\verb!%s(Ruby)! соответствует объекту-идентификатору \verb!:'Ruby'!)

Для каждого объекта, кроме текста, сохраняется также цифровой код, вычисленный на его основе. При повторном использовании той же эмблемы, вместо создания нового объекта, по цифровому коду будет найден уже существующий. Использование цифровых кодов ускоряет поиск и сравнение объектов.
\begin{note}
  Однажды созданный объект-идентификатор будет существовать на всем промежутке времени выполнения программы, поэтому необходимо осторожно подходить к их использованию и делать это только по назначению (с целью управления процессом выполнения программы). Динамическое создание множества объектов идентификатров увеличивает количество памяти, занимаемой программой.
\end{note}

\subsection{Регулярные выражения}

Регулярные выражения -  это мощный инструмент для поиска по тексту. С помощью регулярных выражений составляются образцы, на основе которых выполняется поиск. Использование регулярных выражений в Ruby описывается классом Regexp.

Лексема регулярных выражений - это группа символов (называемая телом регулярного выражения), ограниченная двумя косыми чертами (slash - /). После конечного разделителя может быть использован необязательный модификатор, влияющий на механизм поиска (\verb!/Ruby/i!).

Тело регулярного выражения также может быть записано между двумя произвольными разделителями с использованием приставки \verb!%r!. Модификаторы в этом случае записываются после конечного разделителя (\verb!%r(Ruby)i! – соответствует \verb!/Ruby/i!).

Тело регулярного выражения обрабатывается как составной текст. Одиночные символы, не относящиеся к спецсимволам соответствуют их аналогам в тексте.
Поиск совпадений выполняется последовательно по каждому символу, слева направо.

Полный синтакси регулярных выражений описывается в \hyperlink{appregexp}{\underline{приложении}}.

\section{Составные типы данных}

Составные объекты -  это объекты, содержащие произвольный набор элементов (любых других объектов). Составные типы позволяет группировать объекты и рассматривать их на уровне группы.

\subsection{Индексные массивы}

Индексный массив (или просто массив) - это составной объект, содержащий упорядоченную группу элементов и позволяющий получить доступ к элементу, если известна его позиция (индекс элемента). Элементами массива могут быть любые объекты (даже другие массивы).

Использование массивов в Ruby описывает класс Array.

С точки зрения синтаксиса, индексные массивы - это группа объектов между двумя квадратными скобками. Сами объекты при этом разделяются запятыми: \verb![ 1, "Ruby", ?\u0048 ]!

Существует также специальный синтаксис записи массивов, в качестве элементов которых выступают короткие отрывки текста (состоящие из одного слова и не содержащие пробелов). Такие массивы могут быть записаны в виде группы элементов между двумя произвольными разделителями с использованием приставок \verb!%w! или \verb!%W!. Сами элементы при этом разделяются пробелами.

При использовании приставки \verb!%w! элементы массива будут рассматриваться как простой текст, а при использовании приставки \verb!%W! - как составной.
\\\verb!%W( Язык программирования Ruby )! соответствует массиву:
\\\verb![ "Язык", "программирования", "Ruby" ]!

\subsection{Ассоциативные массивы}

Ассоциативный массив - это составной объект, содержащий упорядоченную группу элементов (каждый из которых представляет собой пару ключ/объект) и позволяющий получить доступ к объекту, если известен его ключ (ключ ассоциируется с объектом). 

\begin{note}
  Для построения соответствий между ключами и объектами используется виртуальная таблица. 

  Объекты, выступающие в роли ключей, в таблице представлены в виде цифровых кодов (небольших целых чисел), получаемых в результате вызова метода .hash. Соответственно сам ключ может быть объектом любого типа, если для него определен этот метод.
\end{note}
  
В ассоциативном массиве можно хранить любые объекты (даже другие массивы).

Использование ассоциативных массивов в Ruby описывает класс Hash.

С точки зрения синтаксиса, ассоциативные массивы - это группа парных элементов ключ/объект между двумя фигурными скобками. Ключи от объектов отделяются символами \verb!=>!. Сами элементы при этом разделяются запятыми: \verb!{ "Ruby" => "language", "Вася" => "Человек" }!.

Один из наиболее распространенных способов использования объектов-идентификаторов - в качестве ключей ассоциативного массива. При этом ассоциативный массив записывают в коде программы, отделяя ключи от объектов двоеточием (при этом двоеточие перед ключом не используется).
\\\verb!{ Ruby: "language", Вася: "Человек" }!
\\ соответствует ассоциативному массиву:
\\\verb!{ :Ruby => "language",  :Вася => "Человек" }!

\subsection{Диапазоны}

Диапазон - это составной тип данных, содержащий упорядоченный набор объектов, располагающихся между заданными границами. 

Использование диапазонов в Ruby описывает класс Range.

С точки зрения синтаксиса, диапазоны - это два однотипых объекта, разделенные двумя или тремя точками. При использовании двух точек в диапазон включается конечная граница (\verb!1..3! содержит числа 1, 2, 3), а при использовании трех - нет (\verb!1...3! содержит числа 1 и 2).

\begin{note}
  Границы диапазона должны принадлежать к одному классу. В этом классе должен быть определен оператор \verb!<=>!, использующийся для сравнение объектов, входящих в диапазон, с его границами.
\end{note}