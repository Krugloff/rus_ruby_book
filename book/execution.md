# Выполнение программы

## Запуск программы

Запуск программ выполняется из терминала. Общий вид команды:  
`ruby [keys] [path] [args]`

+ _keys_ - заранее определенные [спецсимволы или идентификаторы](appbin), влияющие на выполнение программы;  

  _path_ - путь к запускаемой программе. Поиск программы выполняется относительно текущего каталога.

  Если имя программы не указано, или передается одиночный дефис, то интерпретатор будет выполнять код, полученный из стандартного потока для чтения информации (обычно связанного с терминалом).  

  _args_ - произвольный набор символов, которые будут переданы программе как элементы индексного массива ARGV.

Файлы, доступные для выполнения (скрипты или исполняемые файлы), могут содержать информацию об интерпретаторе в первом комментарии (shebang) программы:

`#!/usr/bin/env ruby [keys] [args]`

В этом случае для запуска программы требуется только ввести в терминале путь к ней.

Кроме переданных ключей на выполнение программы также могут влиять [переменные окружения и предопределенные глобальные переменные](appbin).

Переменные окружения - это переменные, установленные операционной системой. В Linux список установленных переменных может быть получен с помощью команды `env`.

## Ход выполнения

Ход выполнения программы - это непосредственное выполнение ее кода.

Ход выполнения может быть разделен на три этапа: подготовка, выполнение и завершение выполнения.

BEGIN и END - это предложения, выполняющиеся на стадиях подготовки и завершения выполнения соответственно. Тело каждого предложения определяет собственную локальную область видимости и выполняется строго один раз.

+ _BEGIN { }_ - код выполняется на стадии подготовки выполнения. Если в коде программы используется несколько таких предложений, то они выполняются последовательно в порядке записи;  

  _END { }_ - код выполняется на стадии завершения выполнения. Если в коде программы используется несколько таких предложений, то они выполняются последовательно в обратном порядке. Для выполнения этого предложения используется экземпляр File, на который ссылается константа DATA;  

  *\_\_END\_\_* - аналогично END;

  *at_exit { }* - аналогично END.

## Перехват выполнения

Перехватить выполнения программы можно с помощью частных методов экземпляров из модуля Kernel.

`.set_trace_func( proc = nil )`

Используется для выполнения переданной подпрограммы при возникновении ряда событий. Перехват выполнения в теле подпрограммы при этом не выполняется.

Подпрограмме передаются: идентификатор события, имя файла, номер строки кода, цифровой идентификатор объекта, экземпляр класса Binding и идентификатор класса объекта.

Передача nil отменяет перехват выполнения.

Возможные события:
+ _"c-call"_ - вызов Си функции;  
  _"c-return"_ - завершение выполнения Си функции;  
  _"call"_ - вызов Ruby метода;  
  _"return"_ - завершение выполнения Ruby метода;  
  _"class"_ - начало определения класса или модуля;  
  _"end"_ - завершение определения класса или модуля;  
  _"line"_ - выполнение новой строки кода;  
  _"raise"_ - вызов ошибки.

`.trace_var( name, code ) # -> nil`

`(name) { |object| } -> nil`

Используется для выполнения кода при изменении глобальных переменных. В блок передается новое значение.

`.untrace_var( name, code = nil ) # -> array`

Используется для отмены перехвата выполнения при изменении глобальной переменной. Возвращается массив, содержащий выполняемый при перехвате код.

## Завершение выполнения

Для завершения выполнения программы используются частные методы экземпляров из модуля Kernel (методы влияют на любой поток выполнения, в теле которого взываются).

`.sleep( sec = nil ) # -> sec`

Используется для временной остановки выполнения (по умолчанию навсегда). В результате возвращается время фактического ожидания.

`.exit( state = true )`

Используется для завершения выполнения с помощью исключения `SystemExit`.

`.exit!( state = false )`

Используется для немедленного завершения выполнения.

`.abort( mesage = nil )`

Используется для немедленного завершения выполнения. Аргумент записывается в стандартный поток для вывода ошибок. Аналогично выполнению `exit false`.

## Вызов системных команд

На Ruby довольно часто создают небольшие скрипты, облегчающие вызов различных системных команд. Для этого используются частные методы экземпляров из модуля Kernel.

``.`(code) # -> string``

Используется для вызова системной команды.  
`ruby --help`

Тот же эффект достигается при ограничении текста произвольными разделителями с использованием приставки `%x` (`%x[ruby --help]`).

`.exec( env, command, options )`

Используется для замены текущего процесса выполнения на выполнение системной команды. Невозможность выполнения команды считается исключением.

##### Аргументы:

`env (hash):` управление переменными окружения.

+ _name:_ значение для переменной окружения;  
  _name:_ nil, удаление переменной окружения.

`command:` системный вызов.

+ _string_ - текст команды для используемой оболочки: по умолчанию в Unix - это `"/bin/sh"`, а в Windows - `ENV["RUBYSHELL"]` или `ENV["COMSPEC"]`;  
  _string, *arg_ - текст команды и передаваемые аргументы;  
  _[ string, first_arg ], *arg_ - текст команды, первый аргумент и остальные аргументы.

`option (hash):` дополнительный аргумент.

+ _unsetenv_others:_ true, удаление всех переменных окружения, кроме переданных методу;  
  _pgroup:_ группировка процессов:
    * true для создания новой группы;
    * integer для сохранения процесса в соответствующей группе;
    * nil для отмены группировки.

  _chdir:_ путь к текущему рабочему каталогу;  
  _umask:_ права доступа для создаваемых файлов или каталогов.

*****

`.syscall( number, *args )`

Используется для выполнения системного вызова с переданным цифровым идентификатором (для Unix систем идентификаторы и функции описаны в файле syscall.h).

Дополнительно (не более девяти аргументов) методу передаются либо текст, содержащий указатель на последовательность байт, либо размер указателя в битах.

Невозможность выполнения системного вызова считается исключением `SystemCallEror`.

Невозможность вызова метода считается исключением `NotImplementedError`.

Метод непереносим и небезопасен в использовании.