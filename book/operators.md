## Операторы

Простейший способ создания сложных выражений - объединение простых с помощью операторов. Операторы - это группа математических символов или знаков препинания. Составные части сложного выражения называют операндами. Операнды, в свою очередь, также относятся к выражениям и могут быть как простыми выражениями, так и сложными.

###### Классификация:

+ Унарные (У)   - оперируют одним операндом;
+ Бинарные (Б)  - оперируют двумя операндами;
+ Тернарные (Т) - оперируют тремя операндами.

Операторы также отличаются приоритетом и последовательностью вычисления операндов.

В сложных выражениях, содержащих несколько операторов, операнды будут вычисляться в порядке увеличения приоритета их операторов.

Если существует несколько операторов с одинаковым приоритетом (или только один оператор), то операнды вычисляются в том порядке, в котором были записаны. При R-последовательности это будет происходит справа налево, а при L-последовательности - слева направо.

Чтобы изменить процесс выполнения выражения, операнды, которые необходимо вычислить в первую очередь, отделяют двумя круглыми скобками.

\pagebreak

~~~~~ longtable
{ | * {5} { l |} }
Приор. & Лексема & Послед. & Тип & Название выражения
1 & ! ~ + & R & У Б У & логическое отрицание; \\* &&&& побитовое отрицание; \\* &&&& унарный плюс
2 & ** & R & Б & возведение в степень
3 & - & R & У & унарный минус
4 & \verb`* / %` & L & Б & произведение (копирование); деление; \\* &&&& остаток от деления (форматирование)
5 & + - & L & Б & сложение (объединение); \\* &&&& вычитание (удаление)
6 & \verb`<< >>` & L & Б & побитовый сдвиг влево (добавление) \\* &&&& побитовый сдвиг вправо
7 & \& & L & Б & побитовое И (пересечение множеств)
8 & \verb`| ^` & L & Б & побитовое ИЛИ (объединение множеств); \\* &&&& побитовое исключающее ИЛИ
9 & < <= > >= & L & Б & отношение
10 & <=> ! = =~ & L & Б & сравнение; неравенство; поиск совпадений
10 & !~ == === & L & Б & отсутствие совпадений; равенство; \\* &&&& проверка условия
11 & \&\& & L & Б & логическое И
12 & || & L & Б & логическое ИЛИ
13 & ?: & R & Т & логическое условие
14 & = & R & Б & присваивание
15 & not & R & У & логическое отрицание
16 & and or & L & Б & логическое И; логическое ИЛИ
~~~~~

\pagebreak

1. **!obj** (логическое отрицание)

  Используется для получения противоположного логического значения.

  ~~~~~ ruby
    !1 # -> false
    !nil # -> true
  ~~~~~

  **~ \\-, integer** (побитовое отрицание)

  Каждый бит числа изменяется на противоположный и дополняется до 1. В результате возвращается десятичное число, необходимое для дополнения. Аналогично выполнению выражения `-number-1`.

  ~~~~~ ruby
    ~1 # -> -2
    ~0b01 # -> -2
  ~~~~~

  **+ number** (унарный плюс)

  Возвращается число в десятичной системе счисления.
  `+0b01 # -> 1`

2. __number**number__ (возведение в степень)

  Используется для возведения числа в степень. Первое операнд - основание степени, а второй - показатель.
  `2**3 # -> 8`

3. **- number** (унарный минус)

  Используется для получения числа, противоположного по знаку.
  `-0b01 # -> -1`

4. __number * number__ (произведение)

  Используется для перемножения двух чисел.
  `1 * 2 # -> 2`

  __string * integer__ (копирование текста)

  Используется для копирования фрагмента текста заданное число раз.
  `"R" * 3 # -> "RRR"`

  __array * integer__ (копирование массива)

  Используется для копирования фрагмента массива заданное число раз.
  `[1, ?R] * 2 # -> [1, "R", 1, "R"]`

  __[*object]__ (извлечение элементов)

  Используется для извлечения элементов составного объекта.

  ~~~~~ ruby
    a = [1, 2, 3]
    [*a] # -> [1, 2, 3]
    [*a, 1] # -> [1, 2, 3, 1]
    b = { a: 1, b: 2 }
    [*b] # -> [ [:a, 1], [:b, 2] ]
    c = 1..4
    [*c] # -> [1, 2, 3, 4]
    [*1] # -> [1]
    [*nil] # -> [ ]
    [*?a] # -> ["a"]
  ~~~~~

  **number / number** (деление)

  Используется для деления двух чисел.
  `-6 / 3 # -> -2`

  **number % number** (остаток от деления)

  Используется для целочисленного деления двух чисел. В результате возвращается остаток.
  ~~~~~ ruby
    7 % 3 # -> 1
    -7 % 3 # -> 2
    7 % -3 # -> -2
  ~~~~~

  **string % object** (форматирование)

  Используется для форматирования объекта согласно правилам, заданным [форматной строкой](appformat). В качестве объектов могут быть использованы числа, текст, индексный и ассоциативный массивы.

5. **number + number** (сложение)

  Используется для сложения двух чисел.
  `1 + 3 # -> 4`

  **string + string** (объединение текста)

  Используется для объединения двух текстов.
  `"Ruby" + ?! # -> "Ruby!"`

  **array + array** (объединение массивов)

  Используется для объединения элементов двух массивов.
  `[1, 2] + [3, 4] # -> [1, 2, 3, 4]`

  **number - number** (вычитание)

  Используется для вычисления разности двух чисел.
  `2 - 1 # -> 1`

  **array - array** (удаление элементов)

  Используется для удаления элементов из первого операнда.
  `[1, 2, 2, ?R] - [2, ?1] # -> [1, "R"]`

6. **number << integer; number >> integer** (побитовый сдвиг)

  Сдвиг влево или вправо каждого бита на указанное количество разрядов.
  `1 << 2 # -> 4`

  **string << string** (добавление текста)

  Используется для добавления фрагмента в конец текста.

  Если вместо второго операнда передается целое число, то оно обрабатывается как кодовая позиция символа.

  ~~~~~ ruby
    "Ruby" << ?! # -> "Ruby!"
    "Ruby" << 33 # -> "Ruby!"
  ~~~~~

  **array << object** (добавление элемента)

  Используется для добавления элемента в конец массива.
  `[1] << 2 # -> [ 1, 2 ]`

7. **integer & integer** (побитовое И)

  Используется для сравнения битов.

  Если биты в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.
  `0b01 & 0b10 # -> 0`

  **array & array** (пересечение множеств)

  Используется для получения элементов, содержащихся в обоих массивах.
  `[1, 2, 2, 3] & [2, 3] # -> [2, 3]`

8. **integer | integer** (побитовое ИЛИ)

  Используется для сравнения битов.

  Если любой из битов в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.
  `0b01 | 0b10 # -> 3`

  **array | array** (объединение множеств)

  Используется для получения элементов, содержащихся хотя бы в одном из массивов.
  `[1, 2, 2, 3] | [2, 3] # -> [1, 2, 3]`

  **integer ^ \\-, integer** (побитовое исключающее ИЛИ)

  Используется для сравнения битов.

  Если один (и только один) из битов в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.
  `0b01 ^ 0b10 # -> 3`

9. **< <= >= >** (отношение)

  Проверка отношения двух объектов.

  Для чисел:

  ~~~~~ ruby
    1 <= 2 # -> true
    1 > 2 # -> false
  ~~~~~

  Для текста:

  При проверке текста последовательно проверяется каждый байт. Первый отрицательный результат станет результатом выполнения всего выражения.

  Каждая следующая буква алфавита считается больше, чем предшественница.

  Любая строчная буква считается больше, чем любая прописная буква.

  ~~~~~ ruby
    "а" < "б" # -> true
    "а" < "Б" # -> false
    "1" <= "2" # -> true
  ~~~~~

10. **object == object** (равенство)

  Проверка равенства двух объектов. Объекты считаются равными, если их значения и типы равны.

  ~~~~~ ruby
    1 == 1.0 # -> true
    1 == "1" # -> false
  ~~~~~

  **object != object** (неравенство)

  Проверка равенства двух объектов.

  ~~~~~ ruby
    1 != 1.0 # -> false
    1 != "1" # -> true
  ~~~~~

  **object === object** (проверка условия)

  Оператор используется для проверки условия. Чаще всего он применяется в составе предложений.

  ~~~~~ ruby
    1 === 1.0 # -> true
    1 === "1" # -> false

    String  === 'matz' # -> true
    Numeric === 42     # -> true
  ~~~~~

  **string =~\\-, regexp; regexp =~\\-, string** (поиск совпадений)

  Используется для поиска по тексту совпадений с [образцом](appregexp). В результате возвращается индекс символа, с которого начинается найденный фрагмент, или ссылка на nil, если совпадений не найдено.

  **string !~\\-, regexp; regexp !~\\-, string** (отсутствие совпадений)

  Проверка отсутствия совпадений.

  **object <=> object** (сравнение)

  Сравнение двух объектов.

  ~~~~~ ruby
              < = >
    # ->  -1 0 1
  ~~~~~

  _-1_ если первый операнд меньше второго;
  _0_ если операнды равны;
  _1_ если первый операнд больше второго;
  _nil_ если сравнение операндов невозможно (разные типы операндов).

  Сравнить можно два числа, текста, индексных массива (последовательно сравнивается каждый элемент).

  ~~~~~ ruby
    1 <=> 1.0 # -> 0
    1 <=> ?2 # -> nil
  ~~~~~

11. **expression && expression** (логическое И)

  Второй операнд вычисляется только при положительном результате вычисления первого операнда.

  ~~~~~ ruby
    4 && 2 - 1 # -> 1
    3 > 4 && 2 - 1 # -> false
  ~~~~~

12. **expression || expression** (логическое ИЛИ)

    Второй операнд вычисляется только при отрицательном результате вычисления первого операнда.

    ~~~~~ ruby
      4 || 2 - 1 # -> 4
      3 > 4 || 2 - 1 # -> 1
    ~~~~~

13. **expression ? expression : expression** (логическое условие)

  В зависимости от результата вычисления первого операнда вычисляется второй операнд (для истинных значений) или третий операнд (для ложных значений)

    ~~~~~ ruby
      1 > 2 ? true : false # -> false
      1 < 2 ? true : false # -> true
    ~~~~~

14. **identificator = object** (присваивание)

  Используется для [присваивания](appassign) значений идентификаторам.

  __**= *= /= %= += -= <<= >>= &&= &= ||= |= ~=__ (псевдооператоры)

  Псевдооператоры - это операторы, получившиеся в результате объединения с оператором присваивания.
  `<1> op= <2>` аналогично `<1> = <1> op <2>`

15. **not object** (логическое отрицание)

  Аналогично `!object`, но с меньшим приоритетом.

16. **expression and expression** (логическое И)

  Аналогично `expression && expression`, но с меньшим приоритетом.

  **experssion or expression** (логическое ИЛИ)

  Аналогично `expression || expression`, но с меньшим приоритетом.
