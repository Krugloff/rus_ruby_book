## Операторы

Операторы - это группа математических символов или знаков препинания, с помощью которой составляются выражения. Составные части этого выражения называют операндами.

###### Классификация:

+ Унарные (У)   - оперируют одним операндом;
+ Бинарные (Б)  - оперируют двумя операндами;
+ Тернарные (Т) - оперируют тремя операндами.

Операторы также классифицируются по приоритету и последовательности вычисления операндов.

В сложных выражениях, содержащих несколько операторов, операнды будут вычисляться в порядке увеличения приоритета их операторов.

Если в выражении существует несколько операторов с одинаковым приоритетом (или только один оператор), то операнды вычисляются в том порядке, в котором были записаны. При R-последовательности это будет происходит справа налево, а при L-последовательности - слева направо.

Чтобы изменить процесс выполнения выражения, операнды, которые необходимо вычислить в первую очередь, отделяют двумя круглыми скобками.

\pagebreak

~~~~~ longtable
{ | * {5} { l |} }
Приор. & Лексема & Послед. & Тип & Название выражения
1 & ! ~ + & R & У & логическое отрицание; \\* &&&& побитовое отрицание; \\* &&&& унарный плюс
2 & ** & R & Б & возведение в степень
3 & - & R & У & унарный минус
4 & \verb`* / %` & L & Б & произведение (копирование); деление; \\* &&&& остаток от деления (форматирование)
5 & + - & L & Б & сложение (объединение); \\* &&&& вычитание (удаление)
6 & \verb`<< >>` & L & Б & побитовый сдвиг влево (добавление) \\* &&&& побитовый сдвиг вправо
7 & \& & L & Б & побитовое И (пересечение множеств)
8 & \verb`| ^` & L & Б & побитовое ИЛИ (объединение множеств); \\* &&&& побитовое исключающее ИЛИ
9 & < <= > >= & L & Б & отношение
10 & <=> != =~ & L & Б & сравнение; неравенство; поиск совпадений
10 & !~ == === & L & Б & отсутствие совпадений; равенство; \\* &&&& проверка условия
11 & \&\& & L & Б & логическое И
12 & || & L & Б & логическое ИЛИ
13 & ?: & R & Т & логическое условие
14 & = & R & Б & присваивание
15 & not & R & У & логическое отрицание
16 & and or & L & Б & логическое И; логическое ИЛИ
~~~~~

\pagebreak

**!operand** (логическое отрицание) RУ1

Используется чтобы получить противоположное логическое значения.

~~~~~ ruby
  !1     # -> false
  !true  # -> false
  !false # -> true
  !nil   # -> true
~~~~~

**~ integer** (побитовое отрицание) RУ1

Каждый бит числа изменяется на противоположный и дополняется до 1. В результате возвращается десятичное число, необходимое для дополнения. Аналогично выполнению выражения `-integer-1`.

~~~~~ ruby
  ~1 # -> -2
  ~0b01 # -> -2
~~~~~

**+ number** (унарный плюс) RУ1

Возвращается число в десятичной системе счисления.

~~~~~ruby
+0b01 # -> 1
~~~~~

__number**number__ (возведение в степень) RБ1

Возведение числа в степень. Первый операнд - основание степени, а второй - показатель.

~~~~~ruby
2**3 # -> 8
~~~~~

**- number** (унарный минус) RУ3

Используется чтобы получить число, противоположное по знаку.

~~~~~ruby
-0b01 # -> -1
~~~~~

__number * number__ (произведение) LБ4

Произведение двух чисел.

~~~~~ruby
1 * 2 # -> 2
~~~~~

__string * integer__ (копирование текста) LБ4

Копирование фрагмента текста заданное число раз.

~~~~~ruby
"R" * 3 # -> "RRR"
~~~~~

__array * integer__ (копирование массива) LБ4

Копирование фрагмента массива заданное число раз.

~~~~~ruby
[1, ?R] * 2 # -> [1, "R", 1, "R"]
~~~~~


**number / number** (деление) LБ4

Частное двух чисел.

~~~~~ruby
-6 / 3 # -> -2
~~~~~

**number % number** (остаток от деления) LБ4

Целочисленное деление двух чисел. В результате возвращается остаток.

~~~~~ ruby
  7 % 3 # -> 1
  -7 % 3 # -> 2
  7 % -3 # -> -2
~~~~~

**format_string % data** (форматирование) LБ4

Форматирование данных согласно правилам, заданным [форматной строкой](appformat). Позволяет форматировать числа, текст, индексный и ассоциативный массивы.

**number + number** (сложение) LБ5

Сумма двух чисел.

~~~~~ruby
1 + 3 # -> 4
~~~~~

**string + string** (объединение текста) LБ5

Объединение двух текстов.

~~~~~ruby
"Ruby" + ?! # -> "Ruby!"
~~~~~

**array + array** (объединение массивов) LБ5

Объединение элементов двух массивов.

~~~~~ruby
[1, 2] + [3, 4] # -> [1, 2, 3, 4]
~~~~~

**number - number** (вычитание) LБ5

Разность двух чисел.

~~~~~ruby
2 - 1 # -> 1
~~~~~

**array - array** (удаление элементов) LБ5

Удаление элементов из первого операнда.

~~~~~ruby
[1, 2, 2, ?R] - [2, ?1] # -> [1, "R"]
~~~~~

**number << integer; number >> integer** (побитовый сдвиг) LБ6

Сдвиг влево или вправо каждого бита на указанное количество разрядов.
`1 << 2 # -> 4`

**string << string** (добавление текста) LБ6

Добавление фрагмента в конец текста.

Если вместо второго операнда передается целое число, то оно обрабатывается как кодовая позиция символа.

~~~~~ ruby
  "Ruby" << ?! # -> "Ruby!"
  "Ruby" << 33 # -> "Ruby!"
~~~~~

**array << element** (добавление элемента) LБ6

Добавление элемента в конец массива.

~~~~~ruby
[1] << 2 # -> [ 1, 2 ]
~~~~~

**integer & integer** (побитовое И) LБ7

Сравнение битов.

Если биты в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.

~~~~~ruby
0b01 & 0b11 # -> 1 (0b01)
~~~~~

**array & array** (пересечение множеств) LБ7

Вычисление элементов, содержащихся в обоих массивах.

~~~~~ruby
[1, 2, 2, 3] & [2, 3] # -> [2, 3]
~~~~~

**integer | integer** (побитовое ИЛИ) LБ8

Сравнение битов.

Если любой из битов в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.

~~~~~ruby
0b01 | 0b11 # -> 3 (0b11)
~~~~~

**array | array** (объединение множеств) LБ8

Вычисление элементов, содержащихся хотя бы в одном из массивов.

~~~~~ruby
[1, 2, 2, 3] | [2, 3] # -> [1, 2, 3]
~~~~~

**integer ^ \\-, integer** (побитовое исключающее ИЛИ) LБ8

Сравнение битов.

Если один (и только один) из битов в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.

~~~~~ruby
0b01 ^ 0b11 # -> 2 (0b10)
~~~~~

**< <= >= >** (отношение) LБ9

Отношение между операндами.

Для чисел:

~~~~~ ruby
  1 <= 2 # -> true
  1 > 2 # -> false
~~~~~

Для текста:

При проверке текста последовательно проверяется каждый байт. Первый отрицательный результат станет результатом выполнения всего выражения.

Каждая следующая буква алфавита считается больше, чем предшественница.

Любая строчная буква считается больше, чем любая прописная буква.

~~~~~ ruby
  "а" < "б" # -> true
  "а" < "Б" # -> false
  "1" <= "2" # -> true
~~~~~

**operand == operand** (равенство) LБ10

Проверка равенства операндов.

~~~~~ ruby
  1 == 1.0 # -> true
  1 == "1" # -> false
~~~~~

**operand != operand** (неравенство) LБ10

Проверка равенства операндов.

~~~~~ ruby
  1 != 1.0 # -> false
  1 != "1" # -> true
~~~~~

**operand === operand** (проверка условия) LБ10

Оператор используется для проверки условия.

~~~~~ ruby
  1 === 1.0 # -> true
  1 === "1" # -> false

  String  === 'matz' # -> true
  Numeric === 42     # -> true
  Float   === 42     # -> false
~~~~~

**string =~\\-, regexp; regexp =~\\-, string** (поиск совпадений) LБ10

Используется для поиска по тексту совпадений с [образцом](appregexp). В результате возвращается индекс символа, с которого начинается найденный фрагмент, или nil, если совпадений не найдено.

**string !~\\-, regexp; regexp !~\\-, string** (отсутствие совпадений) LБ10

Проверка отсутствия совпадений.

**operand <=> operand** (сравнение) LБ10

Сравнение данных.

~~~~~ ruby
         < = >
  # ->  -1 0 1
~~~~~

* _-1_ если первый операнд меньше второго;
* _0_ если операнды равны;
* _1_ если первый операнд больше второго;
* _nil_ если сравнение операндов невозможно (разные типы операндов).

Сравнить можно два числа, текста, индексных массива (последовательно сравнивается каждый элемент).

~~~~~ ruby
  1 <=> 1.0 # -> 0
  1 <=> ?2 # -> nil
~~~~~

**operand && operand** (логическое И) LБ11

Возвращается один из операндов. Второй операнд вычисляется только при положительном результате вычисления первого операнда.

~~~~~ ruby
  4 && false     # -> false
  false && 4     # -> false

  4 && true      # -> true
  true && 4      # -> 4
~~~~~

**operand || operand** (логическое ИЛИ) LБ12

Возвращается один из операндов. Второй операнд вычисляется только при отрицательном результате вычисления первого операнда.

~~~~~ ruby
  4 || false     # -> 4
  false || 4     # -> 4

  4 || true      # -> 4
  true || 4      # -> true
~~~~~

**condition ? result : result** (логическое условие) RТ13

В зависимости от результата вычисления первого операнда вычисляется второй операнд (для истинных значений) или третий операнд (для ложных значений)

~~~~~ ruby
  1 > 2 ? true : false # -> false
  1 < 2 ? true : false # -> true
~~~~~

**identificator = operand** (присваивание) RБ14

Используется для [присваивания](appassign) значений идентификаторам.

__**= *= /= %= += -= <<= >>= &&= &= ||= |= ~=__ (псевдооператоры)

Псевдооператоры - это операторы, получившиеся в результате объединения с оператором присваивания.

`<1> op= <2>` аналогично `<1> = <1> op <2>`

**not operand** (логическое отрицание) RУ15

Аналогично `!operand`, но с меньшим приоритетом.

**operand and operand** (логическое И) LБ16

Аналогично `operand && operand`, но с меньшим приоритетом.

**operand or operand** (логическое ИЛИ) LБ16

Аналогично `operand || operand`, но с меньшим приоритетом.
