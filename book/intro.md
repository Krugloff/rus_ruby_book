# Основные понятия

Язык программирования - это искусственно созданный язык, облегчающий управление компьютером. Текст, написанный с помощью языка программирования называется кодом.

## Краткое описание языка

> Во имя эффективности - причем достигается она далеко не всегда - совершается больше компьютерных грехов, чем по любой другой причине, включая банальную глупость.
>: W. A. Wulf

Эта история началась 24 февраля 1993 года. Японский инженер Юкихиро Мацумото (Matz) решил создать новый язык программирования. Так появился Ruby.

> Я хотел получить скриптовый язык, который был бы мощнее чем Perl, и поддерживал объектную парадигму лучше чем Python. Вот почему я решил разработать свой язык.

Основное назначение Ruby — создание простых и в то же время понятных программ, где важна не скорость работы программы, а малое время разработки, понятность и простота синтаксиса.

###### Идеология Ruby:

+ люди отличаются друг от друга, поэтому существует несколько способов решения одной задачи. Каждый выбирает тот способ, который ему по душе;

+ опытные программисты не должны сталкиваться с неожиданным поведением своих программ (принцип наименьшего удивления);

+ программирование должно приносить удовольствие. Все рутинные действия должны выполняться компьютером.

~~~~~ note
Когда распространение языка только начиналось, очень часто его упрекали за низкую скорость. В последних версиях скорость выполнения была значительно увеличена. Обычно говорят, что Ruby достаточно быстр - скорость выполнения компенсируется скоростью разработки. Медленный код при этом принято переписывать на Си. Си API - одна из полезных и удобных особенностей языка.
~~~~~

###### Особенности Ruby:

+ интерпретируемый;
+ объектно-ориентированный;
+ строгая динамическая неявная типизация;
+ любая синтаксическая конструкция относится к выражениям;
+ гибкий и мощный синтаксис позволяет создавать программы, использующие термины предметной области (DSL);
+ встроенная поддержка интроспекции и метапрограммирования;
+ автоматический сбор мусора;
+ возможность переопределения операторов;
+ все классы доступны для изменения;
+ встроенная поддержка Unicode;
+ встроенная поддержка итераторов, подпрограмм и сопрограмм;
+ возможность создания консольных, графических, мобильных и веб приложений.

## Интерпретаторы

Интерпретатор - это программа, переводящая код в машинные команды, понятные компьютеру.

##### Интерпретаторы:

`MRI` - официальный интерпретатор, написанный на языке программирования Си и использующий виртуальную машину YARV (преимущество виртуальных машин в том, что код сначала интерпретируется полностью, и только затем выполняется).

`Rubinius` - сторонняя реализация виртуальной машины. Написана как с помощью языка программирования C++, так и самого Ruby;

`JRuby` - реализация языка для взаимодействия с виртуальной машиной Java;

`IronRuby` - реализация языка для взаимодействия с платформой .Net.

*****

Официальный [сайт](http://www.ruby-lang.org) языка. На нем можно узнать последние новости разработки интерпретатора, скачать исходный код и перейти к документации.

На этом [сайте](http://rubyinstaller.org) пользователи ОС Windows могут скачать установочный файл для своей операционной системы.

В состав официального интерпретатора входят:

+ стандартная библиотека (наиболее часто используемые модули);
+ менеджер пакетов RubyGems;
+ интерактивный терминал irb (выполняет код на Ruby в режиме реального времени);
+ генератор документации RDoc;
+ программа ri для просмотра документации;
+ менеджер задач Rake;
+ шаблонизатор ERb.

## Краткое описание кода

Программа на Ruby - это код, хранящийся в текстовом файле с определенным расширением (расширение файла - это группа символов, следующая за именем после точки).

Для языка Ruby используются два расширения: `.rb` (стандартное расширение) и `.rbw` (используется в Windows для создания программ с графическим интерфейсом).

Любой интерпретатор понимает только тот код, который написан по заранее определенным правилам. Правила бывают лексическими и синтаксическими.

Лексические правила регулируют определение существующих лексем в коде. Лексема - это последовательность символов, имеющая смысл для интерпретатора. Встретив в тексте набор символов, не относящийся к известным лексемам, интерпретатор завершит обработку кода и вернет сообщение об ошибке.

###### Типы лексем:

+ элементарные типы данных - простейшие данные (числа, буквы, логические величины);

+ идентификаторы - лексемы, использующиеся в двух случаях: для хранения результатов выполнения выражения и для пометки различных синтаксических структур. И то и другое необходимо для повторного применения кода или данных. Лексема идентификатора - это группа символов состоящая из букв, цифр и знаков подчеркивания (`_`). При этом идентификатор не может начинаться с цифры.

  Идентификаторы чувствительны к регистру. Интерпретатор по разному распознает строчные и прописные ASCII символы (принято использовать для идентификаторов именно ASCII символы, хотя в некоторых случаях это необязательное требование). Два идентификатора считаются идентичными только в том случае, если они состоят из одинакового набора байт;

+ операторы - это знаки препинания, использующиеся в качестве разделителей и математичсекие символы, позволяющие выполнять различные вычисления;

+ инструкции - слова, зарезервированные языком программирования. Их переопределение невозможно, а использование приведет к заранее определенному результату. Инструкции используется для создания различных синтаксических структур или для управления процессом выполнения программы.

  Список инструкций: `__LINE__`; `__ENCODING__`; `__FILE__`; `__END__`; BEGIN; END; =begin; =end; alias; and; begin; break; case; class; def; defined?; do; else; elsif; end; ensure; false; for; if; in; module; next; nil; not; or; redo; rescue; retry; return; self; super; then; true; undef; unless; until; when; while; yield;

+ комментарии - текст на естественном языке, поясняющий предназначение программы.

Синтаксические правила регулируют использование выражений в коде. Выражение - это синтаксическая единица, возвращающая результат после выполнения. Выражения могут быть простыми (состоящими из одной лексемы), сложными (состоящими из нескольких простых выражений, операторов или инструкций). Нарушение синтаксических правил приводит к завершению обработки кода интерпретатором.

~~~~~ note
Кроме жестких правил существуют также соглашения, принятые в сообществе. Они необязательны, но крайне желательны к выполнению. Следования правилам позволяет понимать ваш код компьютеру, а следование соглашениям облегчает его понимание для людей.
~~~~~

### Синтаксис выражений

Для упрощения разработки в Ruby присутствует множество дополнений (дополнительные выражения) к синтаксису языка, которые делают его использование более удобным, но не добавляют новых возможностей. Такие дополнения обычно называют синтаксическим сахаром.

Минимальный набор синтаксических правил и соглашений описывает общие особенности употребления выражений в коде.

###### Соглашения:

+ Код принято разбивать на строки. Каждая строка обычно не превышает 80 символов (это облегчает чтение кода);

+ На каждой строке обычно располагается одно логически завершенное выражение (простое или сложное);

+ Выражения обычно составляют таким образом, чтобы результат их выполнения мог быть использован несколько раз.

+ Уровни вложенности выражений принято оформлять двумя пробелами.

###### Синтаксические правила:

+ Для разделения отдельных выражений используется символ перевода строки (невидимый символ, добавляемый текстовым редактором автоматически, при нажатии клавиши `ENTER`);

+ Для разделения выражений на одной строке используется точка с запятой (`;`);

+ Если выражение не помещается на одной строке, то каждую строку, содержащую фрагмент выражения, заканчивают символом обратной косой черты (backslash - `\`), отделяя его пробелом (таким образом он находится прямо перед символом перевода строки и экранирует его). Всякий раз, когда необходимо визуально разбить выражение на несколько строк, а вы не уверены в правильности его обработки - используйте обратную косую черту;

+ Строки, начинающиеся с точки (`.`), также считаются продолжением предыдущего выражения;

+ Пробельные символы (пробел, отступ, перевод строки), не разделяющие выражения, игнорируются интерпретатором и могут использоваться для оформления кода. Однако стоит сохранять осторожность - в некоторых случаях они влияют на процесс выполнения программы.

### Комментарии

Комментарии - это фрагменты текста на естественном языке, поясняющие цель написания кода. Комментарии должны использовать более высокий уровень абстракции (ближайший к человеческому мышлению) чем код.

Создание коротких и качественных комментариев - это одна из полезных способностей для программиста. Такие комментарии помогут разобраться в написанном коде не только другому разработчику, но и самому автору.

Обычно комментарий считается хорошим, если при перепроектировании кода комментарии к нему изменять не требуется.

Хоть наличие комментариев и облегчает понимание кода, главный вклад все же вносится хорошим стилем программирования и следование соглашениям. Никакой комментарий не спасет плохо написанной программы.

Следует помнить, что кроме пользы комментарии также приносят и вред - нарушают визуальное оформление кода.

Комментарии не обрабатываются интерпретатором и не влияют на процесс выполнения программы.

В Ruby существует два способа создания комментариев:

+ Любой текст, начинающийся символом решетки и заканчивающийся переводом строки, считается комментарием.

  ~~~~~ ruby
    # Это комментарий.
    # Это тоже комментарий.
  ~~~~~

+ Любой текст между инструкциями `=begin` и `=end` на отдельных строках считается комментарием. Текст комментария начинается после первого пробельного символа.

  ~~~~~ ruby
    =begin Это тоже комментарий.
      В нем можно записывать все что угодно.
      Обычно его называют встроенной документацией,
      а на первой строке записывают название программы
      для ее обработки.
    =end
  ~~~~~

## Кодировка символов

Текст, который сохраняется в файле, для компьютера существует не в виде символов, а только как двоичные данные - числа из нулей и единиц. Каждый ноль или единица занимают один бит памяти. Восемь нулей или единиц занимают один байт. Обычно удобно записывать байты используя шестнадцатеричную систему счисления. Так ff в шестнадцатеричной системе соотвествует 255 в десятичной и 11111111 в двоичной.

Каждому символу соотвествует определенное число, хранящееся в памяти компьютера. Это число также называется кодовой позицией (code point) символа. Таблица, в которой соотносятся кодовые позиции и символы называется кодовой таблицей.

Кодировка - это способ представления символов в памяти компьютера (в виде набора байт). Например пробел хранится как 10000 (32 в десятичной системе счисления, 20 в шестнадцатеричной). Без информации об используемой кодировке компьютер не сможет правильно отобразить сохраненный набор байт. Обычно понятия кодировки и кодовой таблицы взаимозаменяемы.

В начале появления компьютеров повсевместно использовалась кодировка ASCII, включающая кодовые позиции для 127 символов: цифр, знаков, букв латинского алфавита и спецсимволов. Для предоставления 127 различных кодовых позиций хватает 7 бит памяти, поэтому кодовая позиция в ASCII полностью аналогична байту, хранящемуся в памяти.

В качестве минимальной единицы памяти обычно используется один байт. В одном байте может быть сохранено 255 различных кодовых позиций. Оставшиеся 128 чисел (от 128 до 255) использовались для представления национальных символов: букв национальных алфавитов и специфичных знаков.

Например слово hello хранится в памяти в виде набора байт 48 65 6c 6с 6a. Каждый байт одновременно является кодовой позицией символа.

Обилие национальностей и ограниченный набор различных вариаций битов привели к образованию огромного количества кодировок. Каждая кодировка по разному использовала оставшиеся кодовые позиции, представляя с их помощью разные символы. Это создавало сразу две проблемы: преобразования кодировок и ограниченности набора символов.

Для решения проблемы кодировок был создан стандарт Юникод (Unicode). Юникод был попыткой создать единый набор символов, который будет содержать в себе все символы всех языков на планете. В стандарте определены кодовые позиции символов, но не способ их хранения. Правила, согласно которым кодовые позиции преобразуются в байты (машинное представление), определяются Юникод-кодировками.

Кодовая позиция символа в Юникод записывается в формате U+xxxx, где x - это цифры в шестнадцатеричной системе счисления (может использоваться больше четырех цифр). Количество возможных кодовых позиций превышает миллион, что позволяет стандартизировать большинство существующих алфавитов. На данный момент стандарт содержит кодовые позиции около 100 тыс. символов.

Например, слово hello состоит из пяти кодовых позиций: U+0048 U+0065 U+006C U+006C U+006F.

Разные Юникод-кодировки довольно сильно отличаются. Слово hello может быть закодировано как в виде набора байт 00 48 00 65 00 6С 00 6С 00 6А, так и виде 48 00 65 00 6С 00 6С 00 6А 00. Существуют также кодировки, хранящие каждую кодовую позицию в четырех байтах.

В последнее время чаще всего используется Юникод-кодировка UTF-8. Она совместима с ASCII - для кодирования каждого символа, содержащегося в ASCII используется один байт (слово hello в UTF-8 кодируется так же как и в ASCII). Остальные символы кодируются двумя и более байтами. Это позволяет не хранить в памяти байты, содержащие только нули, и правильно обрабатывать ASCII символы.

Приступая к выполнению программы, интепретатор получает лишь набор байт. В зависимости от внутренней кодировки эти байты могут интерпретироваться по разному. По умолчанию интерпретатор считает, что внутри программы используется кодировка ASCII. Все лексические правила также определены относительно символов, содержащихся в ASCII.

Если в коде или комментариях (ведь это тоже одна из лексем) используются символы, не входящие в ASCII (например кириллица), необходимо вручную указывать кодировку программы.

Если текстовый редактор сохраняет код в кодировке, отличной от ASCII, то она также должна быть явно указана в качестве кодировки программы.

Кодировка устанавливается с помощью специального комментария, расположенного в самом начале программы: `#coding: название_кодировки`

Существует несколько отдельных лексических правил для такого комментария:

+ Вместо coding также может быть использовано encoding;
+ Вместо двоеточия также может использоваться знак равенства;
+ Пробелы до и после двоеточия игнорируются;
+ Весь комментарий не чувствителен к регистру;
+ Перед coding также может использоваться набор символов -*-.

## Краткое описание ООП

Парадигма программирования - это система идей и понятий, определяющих стиль написания компьютерных программ.

Парадигмы прорраммирования не являются взаимоисключающими и, следовательно, могут сочетаться.

Объектно-ориентированная парадигма (ООП) - это парадигма программирования, в которой основными концепциями являются понятия объектов и классов. Большинство основных положений ООП было развито в языке программирования Smalltalk, сильно повлиявшем на Ruby. В настоящее время количество прикладных языков программирования, реализующих ООП, преобладает.

~~~~~ note
Хоть ООП и является достаточно удобной парадигмой, не стоит забывать, что она далеко не единственная. В некоторых случаях применение объектного подхода не оправданно и снижает производительность и удобство создания программ. В любом случае необдуманное и чрезмерное применение концепций ООП усложняет и замедляет выполнение кода, превращая его в бесполезный, малопонятный набор выражений.
~~~~~

ООП развивает идеологию процедурного программирования, где данные и подпрограммы (процедуры или функции) их обработки формально не связаны.

ООП - это не только набор конкретных методик, а также еще и философия проектирования приложений. Как и любая сложная парадигма, ООП состоит из нескольких уровней понимания. Следует заметить, что применение объектно-ориентированного языка Ruby не означает, что код автоматически становится объектно-ориентированным - требуется явная реализация и использование объектно-ориентированных концепций.

Основные понятия ООП - это абстракция, класс, объект, свойство, метод, инкапсуляция, наследование и полиморфизм.

Объектно-ориентированный дизайн - это дисциплина, описывающая способы (варианты) определения объектов и их взаимодействия для решения проблемы, которая определена и описана в ходе объектно-ориентированного анализа. Поведение программы формируется с помощью группы объектов, обменивающихся сообщениями для взаимодействия.

###### Абстракция:

Абстрагирование - это способ выделить существенные свойства и игнорировать несущественные. Соответсвенно, абстракция - это набор выделенных существенных свойств.

Существенные свойства - это свойства, которыми сущность обязана обладать, чтобы быть именно этой сущностью. Несущественные свойства - свойства, обладание которыми необязательно.

С точки зрения сложности, главное достоинство абстракции в том, что она позволяет игнорировать несущественные детали (не имеющие значения для программы). Абстракция - это один из главных способов борьбы со сложностью реального мира.

###### Класс:

Класс - это абстрактная (виртуальная) модель (абстрактный тип данных), еще не существующей сущности. Фактически класс является образцом для создания новых объектов или сущностей (формулой или руководством по эксплуатации). Обычно классы относятся к статичным сущностям, существующим в коде и неизменным в процессе выполнения.

В отличии от объектов, классы обычно не содержат данных. Передача данных классу позволяет создавать объекты, описанного в классе типа (в ООП понятия тип данных и класс - синонимы).

Объект, созданный по образцу класса называют экземпляром этого класса. Основное предназначение классов - определять поведение своих экземпляров. Обычно классы создают таким образом, чтобы они описывали объекты предметной области (объекты реального мира).

Классы позволяют описывать одинаковые сущности только один раз, уменьшая этим размеры и сложность программы.

###### Объект:

В основе ООП находится понятие объекта. Объект - это абстракция изменяемого состояния памяти компьютера. Обычно объекты относятся к динамичным сущностям, создаваемым и изменяемым в процессе выполнения программы.

Объекты обладают состоянием и поведением.

Состояние объекта зависит от значения его свойств (хранимых объектом данных).

Поведение объекта зависит от набора доступных ему методов. Методы - это сообщения, которыми обмениваются объекты. Это абстрактные сущности, определяющие действия, которые можно выполнить над объектом и действия, которые сам объект может выполнять. Пользуясь методами объекта мы можем влиять на его состояние, а посылая сообщения классу мы можем изменять состояние всех его экземпляров.

Таким образом ООП оперирует состоянием, заключенным внутри объекта, и позволяет влиять на него с помощью предоставленных методов.

Создание объектов позволяет уменьшить сложность программы, акцентируя внимание только на использующихся сущностях и их взаимодействии.

###### Инкапсуляция:

Инкапсуляция - это механизм языка, позволяющий сущности объединять в себе данные и методы для работы с этими данными. Данные при этом скрыты от остальной программы, а методы доступны для взаимодействия объектов. Объект не считается отдельной сущностью, если его состояние может быть изменено без явного использования ссылки на объект.

+ Инкапсуляция позволяет распараллелить процессы создания программы, ускоряя разработку ПО;

+ Инкапсуляция снижает сложность разработки, позволяя сосредоточиться на небольших фрагментах программы;

+ Инкапсуляция помогает сокрытию деталей реализации, необходимых программе, но выходящих за рамки абстракции. Инкапсуляция помогает управлять сложностью, скрывая доступ к ней.

###### Наследование:

Наследование - это механизм языка, позволяющий сущности использовать структуру другой сущности, заимствуя и расширяя уже имеющуюся функциональность (например классы расширяют возможности модулей). Класс, который заимствуется (наследуется) называется базовым или суперклассом, а класс, который заимствует (наследует) - производным или подклассом. Все базовые и производные классы в общем создают иерархию классов программы.

+ Наследование снижает время на разработку за счет повторного использования кода;

+ Наследование снижает сложность, позволяя использовать уже известные фрагменты программы. Однако при сложной иерархии повышается объем кода, с которым работает программист в отдельный момент времени;

+ Наследование дополняет абстракцию, выделяя сущности с незначительным уровнем различий. Наследование позволяет создавать абстракции с различным уровнем реализации (дополнительными группами существенных свойств).

###### Полиморфизм:

Полиморфизм - это механизм языка, позволяющий производным классов изменять унаследованное поведение с сохранением общей структуры.

+ Полиморфизм повышает скорость разработки, позволяя быстро подстраиваться под требования заказчика;

+ Полиморфизм снижает сложность, позволяя скрывать внутреннюю структуру объектов;

+ Полиморфизм поддерживает возможность отдельной реализации базовых методов для производных классов.

###### Типизация данных:

> "Если что-то выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка".

В Ruby применяется строгая динамическая неявная типизация.

При строгой типизации совместимость и границы использования типа объекта контролируются интерпретатором и каждый объект имеет тип (использование объектов не подходящего типа считается исключением и приводит к завершению выполнения программы).

При динамической (полиморфной) типизации тип объекта вычисляется во время выполнения и может произвольно изменяться в процессе. Динамическая типизация облегчает реализацию полиморфизма.

При неявной (утиной) типизации (подвид динамической типизации) совместимость и границы использования объекта ограничены его текущим набором методов и свойств, в противоположность наследованию от определенного класса. Утиная типизация ставит во главу угла не тип объекта, а его возможности.

Для того чтобы в Ruby узнать возможность использования того или иного объекта проверяется не его класс, а его реакция на вызов определенных методов в текущий момент. Если реакция объекта удовлетворяет условию, то его использование разрешается. При прочтении этой книги вы встретите множество условий, требующих определенной реакции объекта, на вызов того или иного метода.