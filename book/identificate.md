\chapter{Переменные и константы}

Переменные и константы - это идентификаторы, предназначенные для получения доступа к объектам. Объекты, имеющие идентификатор могут быть использованы повторно. Выражение, связывающее объекты и идентификаторы, называется выражением присваивания. Объект, на который ссылается идентификатор, считается его значением.

~~~~~ note
Переменные и константы также позволяют логически разделить используемые данные. Они облегчают понимание кода, позволяя перейти от терминов языка программирования к терминам решаемой задачи (проблемной области). Адекватность переменной (константы) во многом определяется ее названием. Название переменной можно рассматривать как высокоуровневый псевдокод, характеризующий ее содержимое.
~~~~~

Константы от переменных отличаются только областью применения. Константы используются для доступа к единственному постоянному объекту. В отличии от констант переменные подразумевают многократное использование. Переменная может использоваться как для изменения текущего объекта, так и для изменения значения переменной.

~~~~~ note
На самом деле, в Ruby, переопределение констант не приведет к завершению процесса выполнения программы. Вместо этого интерпретатор просто выведет обычное предупреждение.
~~~~~

Для использования переменных и констант необходимо объявить интерпретатору об их существовании. Переменные и константы считаются существующими после выполнения первого выражения присваивания с их участием. Это выражение называют инициализацией. Процесс инициализации состоит из объявления (создания) идентификатора и определения (присваивания) объекта.

Идентификаторы также могут быть объявлены и без выражения присваивания. Встретив подходящую лексему интерпретатор создаст требуемую переменную или константу. В этом случае определение выполняется автоматически (значением становится nil). Автоматическая инициализация предотвращает ошибки, возникающие при использовании переменных, не имеющих значения. Она также позволяет акцентировать внимание на объектах, а не на переменных.

~~~~~ note
Идентификатор считается объявленным в любом случае если код содержит ее лексему, даже если фрагмент кода не выполнялся (значением становится nil). Это происходит из-за предварительной обработки кода для виртуальной машины.
~~~~~

###### Область видимости:

Фрагмент кода, в котором идентификатор существует и может быть использован.

На основе областей видимости также осуществляется классификация переменных. К базовым областям видимости относятся глобальная и локальные области. Глобальная область видимости распространяется на весь код. Глобальные переменные и константы существуют в любом месте кода (после их инициализации).	Локальная область видимости распространяется только на явно ограниченный фрагмент кода. Локальные переменные и константы существуют только в той части кода, в которой происходила их инициализация.

+ Лексемы локальных переменных начинаются с подчеркивания или строчной буквы (принято использовать только строчные буквы, разделяя слова знаком подчеркивания - змеиная_нотация). Использование не существующей локальной переменной считается вызовом метода;

+ Лексемы глобальных переменных начинаются с знака доллара. Использование не существующей глобальной переменной считается её объявлением;

+ Лексемы констант начинаются с прописной буквы (принято использовать только прописные буквы, разделяя слова знаком подчеркивания - НОТАЦИЯ_ГРЕМУЧЕЙ_ЗМЕИ). Использование не существующей константы считается исключением (поиск констант включает области видимости верхнего уровня).

ООП вводит две дополнительные области видимости: область видимости класса и область видимости экземпляра класса. Так же добавляется два вида переменных.

+ Лексема переменной экземпляра начинается с знака @ (принято использовать змеиную нотацию). Использование не существующей переменной экземпляра считается её объявлением;

+ Лексема переменной класса начинается с @@ (принято использовать змеиную нотацию). Использование не существующей переменной класса считается исключением.

###### Сбор мусора:

Удаление неиспользующихся объектов.

В Ruby ресурсы, используемые программой, управляются интерпретатором. Это позволяет избегать наиболее распространенных проблем работы с памятью. В то же время интерпретатор распознает только заранее определенные ситуации, что иногда приводит к довольно неприятным результатам. Дополнительная работа также увеличивает время интерпретации и выполнения программ. Баланс между этими двумя полюсами - важная задача для разработчиков интерпретатора.

Для автоматического управления памятью реализован механизм, называемый сбором мусора. Под мусором подразумеваются объекты, сохраненные в памяти, но при этом не использующиеся. Как только интерпретатор понимает, что объект не связан ни с одним идентификатором, он освобождает память, которую этот объект занимал (потому что доступ к этому объекту больше невозможен). Это позволяет удалять одноразовые объекты сразу после их использования, а также сохранять синтаксичекие структуры на всем протяжении процесса выполнения.