## Идентификаторы

~~~~~ruby
data
total_sum
create_file
SETTINGS
USER_SETTINGS
mazdaRX7
~~~~~

Идентификаторы - это лексемы, предназначенные для наименования данных или кода. Данные, имеющие идентификатор, могут быть использованы повторно. Эти данные также иногда называют значением идентификатора(или содержимым).

Лексема может состоять только из букв, цифр и знаков подчеркивания (`_`). При этом идентификатор не может начинаться с цифры.

Идентификаторы чувствительны к регистру. Компьютер по разному распознает английские строчные и прописные символы. Два идентификатора считаются идентичными только в том случае, если они состоят из одинакового набора символов;

Перед использованием идентификатора необходимо сначала объявить интерпретатору об его существовании. Идентификаторы считаются существующими после присваивания им значения. Эту операцию называют инициализацией. Процесс инициализации состоит из объявления (создания) идентификатора и присваивания ему значения (содержимого).

~~~~~ note
В Ruby идентификатор считается объявленным в любом случае если код содержит его лексему, даже если фрагмент кода не выполнялся (значением становится nil). Это происходит из-за предварительной обработки кода для виртуальной машины.
~~~~~

Синтаксис выражения присваивания подробно описан в [приложении](appassign). Изучите его прежде чем читать дальше.

### Переменные и константы

~~~~~ruby
local_var
$global_var
_unused_var
CONSTANT
~~~~~

Переменные и константы - это идентификаторы, отличающиеся способом применения и областью видимости.

Константы используются для доступа к данным, которые не изменяются в процессе выполнения программы. В отличии от констант, использование переменных подразумевает что данные будут изменены в процессе.

~~~~~ note
На самом деле, в Ruby, изменение значения константы не приведет к завершению выполнения программы. Вместо этого интерпретатор просто выведет обычное предупреждение.
~~~~~

Кроме области применения, идентификаторы также различают по областям видимости. Область видимости идентификатора - это фрагмент кода, в котором идентификатор существует и может быть использован.

К базовым областям видимости относятся глобальная и локальные области. Глобальная область видимости распространяется на весь код. Глобальные переменные и константы существуют в любом месте кода (после их инициализации).	Локальная область видимости распространяется только на явно ограниченный фрагмент кода. Локальные переменные и константы существуют только в той части кода, в которой происходила их инициализация.

+ Лексемы локальных переменных начинаются с подчеркивания или строчной буквы (принято использовать только строчные буквы, разделяя слова знаком подчеркивания - змеиная_нотация).

+ Лексемы глобальных переменных начинаются с знака доллара. Использование несуществующей глобальной переменной считается её объявлением;

+ Лексемы констант начинаются с прописной буквы (принято использовать только прописные буквы, разделяя слова знаком подчеркивания - НОТАЦИЯ_ГРЕМУЧЕЙ_ЗМЕИ). Использование несуществующей константы считается ошибкой.

~~~~~ note
Обычно если переменная объявлена, но при этом нигде не используется (иногда требуется и такое), интерпретатор выводит предупреждение. Чтобы избежать этого в качестве неиспользуемой переменной используют `_` или любой другой идентифкатор, начинающийся с подчеркивания.
~~~~~

~~~~~ note
Переменные и константы также позволяют логически разделить используемые данные. Они облегчают понимание кода, позволяя перейти от терминов языка программирования к терминам решаемой задачи (проблемной области). Но это сработает только в том случае, если название идентификатора подобрано со смыслом, характеризующим его  содержимое.
~~~~~

### Сбор мусора

Любые данные, используемые программой, занимают место в памяти компьютера. Чем больше данных используется, тем больше памяти требует программа. Если не удалять старые данные, хранить которые больше нет необходимости, то программа может использовать всю доступную память, что замедлит выполнение других программ или даже может привести к сбою работы компьютера.

В Ruby ресурсы, используемые программой, управляются интерпретатором, а не разработчиком. Это позволяет избегать наиболее распространенных ошибок при работе с памятью, снимая с разработчиков обязанность управлять ее вручную. В то же время интерпретатор распознает только заранее определенные ситуации, что иногда приводит к довольно запутанным проблемам (поэтому разработчики программ должны знать о наиболее вероятных проблемах с памятью и путях их решения). Кроме того, дополнительная работа также увеличивает время интерпретации и выполнения программы. Баланс между удобством управления ресурсами и скоростью выполнения программы - важная задача для разработчиков интерпретатора.

Механизм автоматического управления памятью называется сбором мусора. Под мусором подразумеваются данные, сохраненные в памяти, но при этом не использующиеся. Как только интерпретатор понимает, что данные не связаны ни с одним идентификатором, он освобождает память, которую эти данные занимали. Это позволяет хранить только те данные, которые будут использованы далее в программе. К сожалению, запуск сборщика мусора (для поиска и удаления несипользуемых данных), замедляет выполнение программы и требует дополнительных ресурсов компьютера.
