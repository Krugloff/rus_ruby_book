# Реализация ООП

Одна из главных особенностей Ruby - сильно выраженная поддержка объектно-ориентированной парадигмы.

+ Любые данные, в том числе и элементарные, относятся к объектам.
+ Большинство операторов относится к методам.
+ Множество синтаксического сахара облегчает использование основных технологий и сущностей ООП.

###### Основные особенности:

+ Любые данные хранятся в виде объектов;

+ Вычисления выполняются путем взаимодействия (обмена данными) между объектами, при котором один из объектов требует выполнение некоторого действия от другого. Объекты взаимодействуют с помощью методов. Метод - это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при его выполнении;

+ Каждый объект имеет независимую память, которая состоит из других объектов;

+ Каждый объект является представителем класса, который определяет общие свойства объектов;

+ В классе также определяется поведение объекта - набор доступных методов. Все экземпляры класса могут выполнять одни и те же действия;

+ Классы организованы в единую древовидную структуру с общим корнем, называемую иерархией наследования. Память и поведение экземпляров базового класса автоматически доступны в производном классе.

## Основные сущности

### Модули (Module)

Модули - это абстрактные сущности, использующиеся для инкапсуляции методов, констант или фрагмента программы.

~~~~~ note
  В качестве пространств имен модули обычно используются для инкапсуляции области видимости программы. При этом все классы или модули программы объявляются только в теле одного отдельного модуля. Это позволяет разным программам не засорять глобальную область видимости. Использование глобальной области видимости программой считается плохим тоном среди программистов, т.к. требует согласования использованных имен классов и модулей и может привести к непредсказуемым последствиям.

  Явно выраженный пример инкапсуляции логически связанных фрагментов кода представляет модуль Math, объединяющий математические функции.
~~~~~

С точки зрения синтаксиса модуль - это фрагмент кода, связанный с константой. В отличии от классов модули не могут иметь экземпляров или производных, поэтому любой класс может считаться модулем, но не любой модуль - считаться классом.

Создание модуля называется объявлением, а заполнение области видимости модуля - определением.

~~~~~ ruby
  module идентификатор_модуля
    тело_модуля
  end
~~~~~

+ Инструкция module ожидает получения константы, сообщая интерпретатору область памяти в которую необходимо выполнить запись информации. Если соответствующей области не существует, то автоматически объявляется новый модуль. В другом случае будет изменен уже существующий модуль;

+ В теле модуля существует отдельная область видимости. В ней могут создаваться любые другие сущности. Внутри тела модуля псевдопеременная self ссылается на модуль. В результате создания модуля возвращается результат выполнения последнего выражения в теле (обычно это nil).

Модули также относятся к экземплярам класса Module. Методы экземпляров, определенные в этом классе, могут вызываться для всех модулей.

`::new { nil } # -> module [Module]`

Используется для создания анонимного модуля. Необязательный блок выполняется в теле модуля. Модуль перестанет быть анонимным, если будет присвоен константе.

### Классы (Class)

Класс - это абстрактная сущность, расширяющая поведение модулей, применяемая для описания структуры и поведения ее экземпляров. Создание класса называется объявлением, а описание его экземпляров - определением. Любой класс (даже встроенный) может быть переопределен в любом месте кода.

~~~~~ ruby
  class идентификатор_класса
    тело_класса
  end
~~~~~

+ Инструкция class ожидает получения константы, сообщая интерпретатору область памяти в которую необходимо выполнить запись информации. Если соответствующей области не существует, то автоматически объявляется новый класс. В другом случае будет изменен уже существующий класс.

+ В теле класса создается отдельная область видимости. В ней может определяться поведение экземпляров класса или любые другие сущности. Внутри тела класса псевдопеременная self ссылается на класс. В результате создания класса возвращается результат выполнения последнего выражения в теле класса (обычно это nil).

Классы также относятся к экземплярам класса Class. Методы экземпляров, определенные в этом классе, могут вызываться для всех остальных классов.

`::new( class = Object ) # -> class [Class]`

Используется для создания анонимного класса, наследующего переданному. Класс перестанет быть анонимным, если будет присвоен константе.

**Экземпляры классов:** объекты, создаваемые с помощью классов.

Методы, используемые для создания объекта, называются конструкторами. По умолчанию в Ruby для каждого класса определен конструктор `::new`. Этот метод выполняет два действия: создает область памяти для объекта (метод `.allocate`) и заполняет эту область (метод `.initialize`).

Метод `.initialize` должен определяться разработчиком. Определяемый метод автоматически становится частным. Инициализируемые в нем переменные экземпляра доступны для любого метода создаваемого объекта.

~~~~~ note
  Метод .allocate уже определен в классе Class и его переопределение обычно не требуется.
~~~~~

**Собственный класс объекта:** отдельный класс для каждого объекта.

Каждый объект кроме класса, к экземплярам которого относится, имеет еще и свой собственный класс. С помощью собственных классов для объектов определяется уникальное поведение. Собственные классы также называют метаклассами (metaclass).

~~~~~ ruby
  class << объект
    тело_класса
  end
~~~~~

Это предложение определяет собственный класс для переданного объекта (объект рационально передавать с помощью переменной). В теле класса в этом случае используется псевдопеременная self.

Возвращается результат выполнения последнего выражения в теле собственного класса объекта (обычно это nil).

~~~~~ note
Следует запомнить, что классы не наследуют методы своих собственных классов, а относятся к их экземплярам.
~~~~~

### Константы

Константы определяются в теле модуля и служат для хранения известных и не изменяющихся данных, общих для всего класса.

Использовать константу можно с помощью бинарного оператора `::`, имеющего наивысший приоритет и последовательность выполнения L. В качестве левого операнда используется идентификатор модуля, а в качестве правого операнда - константа. Использование константы называют ее вызовом.  
`класс::константа`

Использование этого выражения с оператором присваивания `=`, позволяет изменить константу в любом месте кода.

Для того, чтобы вызвать константу, интерпретатор должен определить какая именно константа должна быть использована. При полной записи выражения поиск осуществляется в указанном классе. При отсутствии левого операнда по умолчанию используется псевдопеременная self.

При наличии только константы, поиск будет выполняться в соответствии с иерархией областей видимости.

1. В теле класса, в котором была вызвана константа;
2. В теле модуля, в котором определяется класс;
3. В теле модуля, добавленного к классу;
4. Вверх по иерархии областей видимости с выполнением пунктов 1-3;
5. Вызов метода `object.const_missing` для класса, в теле которого была вызвана константа.

### Переменные

Переменные определяются в теле класса и служат для хранения изменяющихся данных: состояния класса и его экземпляров. Переменные могут существовать в двух различных областях видимости: области видимости класса и области видимости экземпляра класса.

**Переменные класса:** переменные, объявляемые в области видимости класса.

Переменные класса могут быть объявлены в любом месте тела класса (в том числе и в теле метода). Лексема переменной начинается с символов @@.

Переменная класса может быть использована в любом месте тела класса (в том числе и в теле метода). Она ссылается на один и тот же объект для всех его экземпляров.

Переменные класса используются для хранения изменяющихся данных, общих для всех экземпляров класса. Обычно переменные класса инициализируются в теле класса и используются в теле его методов. Использование несуществующей переменной класса считается ошибкой.

**Переменные экземпляра:** переменные, объявляемые в области видимости экземпляра класса.

Переменные экземпляра могут быть объявлены в теле метода экземпляров. Лексема переменной начинается с символа @.

Переменная экземпляра может быть использована в теле любого метода экземпляров. Она ссылается на разные объекты для каждого отдельного экземпляра.

Переменные экземпляра используются для хранения состояния экземпляров класса. Обычно переменные экземпляра инициализируются в теле метода в момент его вызова. Использование несуществующей переменной экземпляра считается её объявлением.

Если определить переменную экземпляра в теле класса, а не в теле метода, то она будет связана с классом, а не с его экземплярами. Такие переменные недоступны в теле методов и фактически относятся к переменным экземпляра объекта, принадлежащего к классу Class.

### Методы

Методы - это абстрактные сущности, определяющие действия, которые может выполнять объект, и действия, которые можно выполнять с самим объектом (например, изменять его состояние). Выполняемые действия делятся на два вида: функции и процедуры. В Ruby их четкого синтаксического разграничения не существует - процедуры входят в подмножество функций. С точки зрения языка программирования, метод относится к выражениям.

+ _Функция_ - это метод, используемый для получения объекта (например математические функции);

  _Процедура_ - это метод, используемый для выполнения действия (например сохранение данных в файл). В результате выполнения процедуры обычно возвращается статус выполнения (логическая величина) или ссылка на объект, для которого вызывалась процедура.

С точки зрения синтаксиса, метод - это именованный фрагмент кода, выполняющий одну конкретную задачу. Методы определяются в теле класса. В результате определения возвращается nil. Каждый метод связан с тем объектом, для которого был определен и не может использоваться без ссылки на него. Использование метода также называют вызовом.

#### Определение метода

**Методы экземпляров класса:** методы, определяющие поведение экземпляров класса.

~~~~~ ruby
  def идентификатор_метода(параметры)
    тело_метода
  end
~~~~~

Хранение методов экземпляров - это главное отличие классов от остальных сущностей.

**Методы класса:** методы, определяющие поведение класса.

~~~~~ ruby
  def класс.идентификатор_метода(параметры)
    тело_метода
  end
~~~~~

Вместо идентификатора класса может использоваться псевдопеременная self. Это повышает переносимость кода, определяя метод для любого текущего класса, а не для какого-то конкретного.

Методы класса не являются отдельной сущностью - это всего лишь методы, создаваемые в теле собственного класса объекта (объектом в этом случае считается класс).

###### Класс:
+ методы экземпляров хранятся в теле класса;
+ методы класса (собственные методы) хранятся в теле собственного класса объекта (объектом в данном случае является класс).

Следовательно главное отличие классов от обычных объектов в возможности хранить методы своих экземпляров.

##### Синтаксис метода:

`Идентификатор метода:` лексема идентификатора метода аналогична лексеме локальной переменной.

Обычно имя метода выбирается в соответствии с его целью:

+ Для именования процедур используются глаголы;
+ Имя функции обычно описывает объект, который она возвращает;
+ Имя методов с побочным эффектом заканчивается восклицательным знаком (добавляется только если существует версия метода без побочного эффекта);
+ Предикаты - это методы, утверждающие или отрицающие что-либо об объекте. В результате выполнения предиката возвращается логическая величина, характеризующая истинность или ложность утверждения. Имя предиката обычно заканчивается вопросительным знаком.

`Параметры:` локальные переменные, которые служат для разделения аргументов (объектов, передаваемых методу при вызове).

Несколько параметров отделяются запятыми. При вызове метода параметры будут последовательно инициализироваться переданными аргументами с помощью выражения присваивания.

+ Когда параметр инициализируется при объявлении метода, то он имеет значение по умолчанию. Это значение будет использоваться, если при вызове метода необходимый аргумент не передавался. Значения по умолчанию могут быть произвольными выражениями, переменными экземпляра или даже другими параметрами, объявленными ранее. Параметры, имеющие значение по умолчанию, должны объявляться последовательно;

+ Когда перед параметром используется оператор разыменования (`*`), то такой параметр принимает произвольное количество аргументов, сохраняемых в массиве. Подобный тип параметров объявляется после параметров, имеющих значение по умолчанию. Допускается существование только одного такого параметра для метода;

+ Когда перед последним параметром используется амперсанд (`&`), то такой параметр принимает блок (вызывая для аргумента метод `.to_proc`). В теле метода может использоваться как параметр, так и инструкция yield.

~~~~~ note
Для повышения читабельности параметров, ссылающихся на логическую величину может использоваться приставка is.
~~~~~

`Тело метода:` фрагмент кода, выполняемый в момент вызова метода.

Тело метода использует область видимости объекта. В ней доступны объявленные параметры и переменные экземпляра. В теле метода псевдопеременная self ссылается на объект, для которого метод был вызван.

*****

**Синонимы:** копия метода, имеющая другой идентификатор.

Для метода может быть определено любое количество синонимов. Синонимы могут быть созданы только в теле класса, объявляющего метод.

Создание синонима выполняется с помощью инструкции alias:
`alias синоним идентификатор_метода`

~~~~~ note
Запомнить синтаксис выражения будет проще, если рассматривать его относительно выражения присваивания: синоним = метод.
~~~~~

**Удаление метода:** выполняется с помощью инструкции undef. Ее можно использовать только в теле класса, определяющего данный метод или в теле его подклассов (в этом случае метод будет удален только для отдельного подкласса).  
`undef идентификатор_метода`

###### Ruby 2.0

Раньше для передачи именованных аргументов использовались ассоциативные массивы. Теперь для этого могут объявляться именованные параметры. Они существуют во многих языках, а теперь добавлены и в Ruby.

Именованные параметры - это синтаксический сахар, облегчающий идентификацию получаемых аргументов.

+ Когда после параметра используется двоеточие, то он считается именованным. Значение после двоеточия будет считаться значением по умолчанию.

  ~~~~~ ruby
    def method(name: default); name; end
    method(name: 'method') # -> method
  ~~~~

  Передача необъявленных именованных аргументов считается исключением.

  ~~~~~ ruby
    def method(name: default); name; end
    method(args: 'method') # -> ArgumentError!
  ~~~~

+ Когда перед параметром используется разыменование (`**`), то такой параметр принимает произвольное количество именованных аргументов, сохраняемых в ассоциативном массиве. Имя параметра указывать обязательно (нельзя использовать только `**`)

  ~~~~~ ruby
    def method(**options); options; end
    method(name: 'method') # -> { name: 'method'}
  ~~~~

#### Блоки

Блоки - одна из особенных синтаксических конструкций в Ruby, предоставляющая мощные возможности по выполнению кода.

Блоки - это один из вариантов создания замыканий. Они являются частью окружающего кода и могут использовать объявленные переменные.

С точки зрения синтаксиса, блок - это фрагмент кода, связанный с группой параметров. Блоки не могут использоваться сами по себе, а только передаваться методам. Блок всегда должен передаваться методу последним. Если объект не использует блок, то его передача игнорируется.

` <method> { |параметры| тело_блока }`  
или

~~~~~ ruby
  <method> do |параметры|
    тело_блока
  end
~~~~~

Открывающая фигурная скобка или инструкция do относятся к предыдущему выражению - остальные аргументы необходимо ограничивать круглыми скобками, иначе блок будет передан последнему аргументу.

~~~~~ note
Методы, позволяющие перебирать элементы составного объекта, не зависимо от их типа, называются итераторами. Перебор элементов выполняется с помощью блока, которому они передаются. Каждое отдельное выполнение блока называется итерацией. В результате выполнения итератора обычно возвращается ссылка на объект, для которого он был вызван.

Вместо блока итераторы также могут принимать идентификатор метода, начинающийся с амперсанда. В этом случае метод будет вызван для каждого элемента составного объекта.

Итераторы в Ruby - это синтаксический сахар, использующийся вместо предложения перебора (for in).
~~~~~

##### Синтаксис блока:

`Параметры:` локальные переменные, которые служат для разделения аргументов (объектов, передаваемых блоку).

Несколько параметров отделяются запятыми. При выполнении блока параметры будут последовательно инициализироваться переданными аргументами с помощью выражения присваивания.

Параметры блока не могут иметь значений по умолчанию или принимать блоки. Однако они могут ссылаться на массив аргументов (с помощью оператора разыменования `*`).

`Тело блока:` создает собственную область видимости. В нем определены объявленные в окружающем коде переменные, параметры и переменные экземпляра. В теле блока псевдопеременная self ссылается на объект, для которого был вызван метод, принимающий блок.

Блок относится к замыканиям - в теле блока существуют локальные переменные, объявленные в окружающем коде. Чтобы явно указать переопределение локальных переменных, их идентификаторы отделяют от параметров блока точкой с запятой (`| x, y; z, k, n |`). Переопределенные локальные переменные в теле блока будут ссылаться на nil.

*****

**Выполнение блока:** блок выполняется в момент вызова. Возвращается результат выполнения последнего выражения.

Для вызова блока в теле метода используется инструкция yield, которой передаются аргументы, отправляемые в блок (нельзя передавать блоки). Избыток аргументов игнорируется. Возвращается результат выполнения блока.

Использование инструкции yield при отсутствии блока считается исключением `LocalJumpError`.

Присваивание аргументов параметрам выполняется так же, как и выражение присваивания.

~~~~~ ruby
  hash = { a: [], b: [] }
  hash.each { |key, (first_in_value, second_in_value)| }
~~~~~

Ход выполнения блока может регулироваться с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции становится результатом выполнения (по умолчанию nil).

##### Инструкции:

`return [код]` - используется для завершения выполнения блока и всех методов, в теле которых оно выполняется, продвигаясь вверх по областям видимости;

`break [код]` - используется для завершения выполнения блока и принимающего блок метода;

`next [код]` - используется для завершения выполнения блока. Итератор может начать новую итерацию;

`redo` - используется для повторного выполнения блока.

*****

#### Вызов метода

Методы вызываются с помощью бинарного оператора `.` (или `::`, но он обычно не используется или используется только для вызова методов класса), имеющего наивысший приоритет и последовательность выполнения L. Левым операндом должен быть объект, для которого вызывается метод (получатель сообщения), а правым операндом - идентификатор метода.  
`объект.идентификатор_метода(аргументы)`

Аргументы - это группа объектов, инициализирующих параметры. Несколько объектов разделяются запятыми. Недостаток или избыток аргументов считается исключением. Количество требуемых аргументов соответствует количеству объявленных параметров.

Возвращается результат выполнения последнего выражения в его теле. Вызов метода без указания объекта вызывает его для псевдопеременной self.

Аргументы классифицируют по способу их передачи.

+ Передача по значению - метод копирует переданный аргумент. Изменение параметра не влияет на передаваемый аргумент;

+ Передача по адресу - передаваемым значением является адрес, по которому можно найти значение переменной;

+ Передача по ссылке - метод копирует не переданный аргумент, а его адрес, однако использует синтаксис, при котором работа выполняется с объектом, хранящимся по этому адресу. Изменение параметра также изменит переданный аргумент.

~~~~~ note
Автор книги разделяет точку зрения, что в Ruby все аргументы передаются по ссылке. Это отражает суть происходящего при изменении состояния передаваемых аргументов, но читателям также стоит обратить внимание на то, что передача аргументов методам, имеет свою специфику, связанную в основном с выражением присваивания и тонкостями терминологии в контексте языков высокого уровня.
~~~~~

###### Синтаксис вызова:

+ использование круглых скобок при вызове метода не обязательно (кроме случаев, когда методу передается блок);

+ когда последним аргументом метода передается ссылка на ассоциативный массив, то использование фигурных скобок для выделения массива не требуется;

+ для извлечения элементов составного объекта используется оператор разыменования (`*`). Элементы извлекаются с помощью метода `.to_splat`;

+ для передачи блока, аргумент должен передаваться последним и начинаться с амперсанда (`&`).

Перед вызовом метода интерпретатор должен определить какой именно метод использовать. Поиск метода осуществляется в соответствии с иерархией наследования класса объекта (учитывается и собственный класс объекта).

+ в собственном классе объекта;
+ в теле класса объекта;
+ в теле модуля, добавленного к классу;
+ вверх по иерархии классов с выполнением пунктов 2 и 3;
+ вызов для объекта метода `.method_missing`.

###### Ruby 2.0

+ для извлечения элементов ассоциативного массива используется оператор разыменования (`**`). Несколько ассоциативных массивов подряд будут объединяться.

  ~~~~~ ruby
    APP_OPTS = { name: 'play', author: 'dave' }
    LOG_OPTS = { level: 2, color: 'blue', line: '3pt' }

    def log(msg, options)
      p msg
      p options
    end

    log( 'Starting', **APP_OPTS )
      # ->
      # 'Starting'
      # { name: 'play', author: 'dave' }

    log( 'Connected', **APP_OPTS, **LOG_OPTS )
      # ->
      # 'Connected'
      # { name: 'play', author: 'dave',
      #   level: 2, color: 'blue', line: '3pt' }

    log( 'Giving up', **APP_OPTS, **LOG_OPTS, color: 'VERY RED' )
      # ->
      # 'Giving up'
      # { name: 'play', author: 'dave',
      #   level: 2, color: 'VERY RED', line: '3pt' }
  ~~~~~

#### Ход выполнения

Ход выполнения метода может регулироваться с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции становится результатом выполнения (по умолчанию возвращается nil).

##### Инструкции:

`return [код]` - используется для завершения выполнения метода;

`break [код]` - создание исключения;

`next [код]` - создание исключения;

`redo` - создание исключения.

*****

**Собственный метод объекта:** метод, определенный в собственном классе объекта.

Собственные методы объекта могут быть определены либо в теле собственного класса (как методы экземпляров), либо с помощью отдельного предложения.

~~~~~ ruby
  def объект.метод
    тело_метода
  end
~~~~~

Определение такого метода возможно только после создания объекта (объект также должен существовать в текущей области видимости). Очевидно, что объект должен быть представлен в виде переменной или константы.

В результате возвращается nil.

Поведение всего класса зависит от набора существующих методов класса. Поэтому, неудивительно, что методы класса также относятся к собственным методам объекта (которым в данном случае является класс).

### Примеры

Определение простого класса в теле модуля.

Метод `.to_s` используется при отображении экземпляра класса.


~~~~~ ruby
  module OurKlass
    class User
      @@count = 0 # class var.

      # class method.
      def self.count
        @@count
      end

      def initialize( name, age )
        @name = name # instance var.
        @age = age
        @@count += 1
        @id += 1
      end

      # instance method.
      def to_s
        "#{@name}: #{@age} years old"
      end

    end # class User.
  end # module.
~~~~~

Создание экземпляра класса. Метод `.to_a` еще не определен.

~~~~~ ruby
  user = OurKlass::User.new "Timmy", 22 # -> "Timmy: 22 years old"
  OurKlass::User.count # -> 1
  user.to_a # -> error!
~~~~~

Определение метода `.to_a`.

~~~~~ ruby
  class OurKlass::User
    def to_a
      [ @name, @age ]
    end
  end

  user.to_a # -> ["Timmy", 22]
~~~~~

Различные способы определения метода класса.

~~~~~ ruby
  class OurKlass::User
    def self.next_count
      @@count + 1
    end
  end

  OurKlass::User.next_count # -> 2

  class OurKlass::User
    class << self
      def prepend_count
        @@count - 1
      end
    end
  end

  OurKlass::User.prepend_count # -> 0
~~~~~

Определение собственного метода объекта. При переопределении переменной для нового объекта метод определен уже не будет.

~~~~~ ruby
  class << user
    def id
      @id
    end
  end

  user.id # -> 1
  user = OurKlass::User.new "Tommy", 33 # -> "Tommy: 33 years old"
  user.id # -> error!
~~~~~

## Основные принципы

### Инкапсуляция

#### Инкапсуляция состояния

По умолчанию состояние объекта доступно только внутри объекта. Поэтому для получения или изменения значения переменных экземпляра или класса требуется явно определять соответствующие методы, также называемые свойствами. Свойства позволяют получать состояние объекта (читать значение переменной) изменять состояние объекта (определять значение переменной).

Свойства для получения состояния обычно просто возвращают текущее значение переменой. Для этого в конце тела метода, последним выражением должен быть идентификатор необходимой переменной.

Для изменения состояния в конце тела метода, последним выражением должно быть выражение присваивания, в котором участвуют идентификатор требуемой переменной и переданный методу аргумент. Идентификатор свойства при этом обычно заканчивается знаком равенства (`<attr>=`).

Для объявления свойств могут использовать частные методы экземпляров из класса Module.

`.attr_accessor(*attribute) # -> nil`

Используется для объявления переменной экземпляра и свойств для получения и изменения её значения.

`.attr_reader(*attribute) # -> nil`

Используется для объявления переменной экземпляра и свойства для получения её значения.

`.attr_writer(*attribute) # -> nil`

Используется для объявления переменной экземпляра и свойства для изменения её значения.

#### Инкапсуляция поведения

Инкапсуляция поведения осуществляется посредством ограничения доступа к методам.

Методы могут быть как внутренними (обеспечивающими логику функционирования объекта), так и внешними (используемыми для взаимодействия объектов). Доступ к внутренним методам может быть ограничен областью видимости класса.

###### Классификация методов:

+ _public_ - общие методы. Общие методы позволяют объектам взаимодействовать друг с другом. Они могут быть вызваны в любой области видимости;  

  _protected_ - защищенные методы. Защищенные методы позволяют объектам одного типа взаимодействовать друг с другом. Они могут быть вызваны только в области видимости класса (и его производных) или экземпляров класса (и его производных) и только для экземпляров того же класса (и его подклассов);  

  _private_ - частные методы. Частные методы реализуют внутреннюю логику объекта. Они могут быть вызваны только в области видимости класса (и его производных) или экземпляров класса (и его производных) и только для текущего экземпляра (частные методы всегда вызываются для псевдопеременной self). Частные методы помогают скрывать реализацию работы программы и разрешить доступ только к API.

Частные методы реализуют инкапсуляцию поведения объекта, а защищенные - инкапсуляцию поведения класса объектов.

Область применения метода объявляется с помощью частных методов экземпляров из класса Module: `.public`, `.private` и `.protected`. Ограничивается применение указанных методов или методов, объявляемых после. Методы, определяемые вне тела класса, относятся к частным методам класса Object.

`.private_class_method(*name) # -> self [Module]`

Используется для объявления методов класса частными. Обычно применяется для инкапсуляции конструкторов.

`.public_class_method(*name) # -> self [Module]`

Используется для объявления методов класса общими.

`.module_function(*name) # -> self [PRIVATE: Module]`

Используется для объявления методов экземпляров частными и создания аналогичных методов модуля. Это позволяет использовать методы либо непосредственно с помощью модуля, либо добавляя их к уже существующему классу.

При вызове без аргументов влияет на все методы, объявленные далее.

### Наследование и агрегация

#### Наследование

Реализация наследования в Ruby позволяет создавать производные классы (использовать функциональность уже существующих классов).

В Ruby реализовано единичное наследование. Это означает, что любой класс может иметь только один базовый класс.

Наследование класса может быть выражено словосочетанием "относится к" или "принадлежит к".  
`class производный_класс < базовый_класс`

+ Переменные экземпляра не наследуются;

+ Переменные класса наследуются его производными. При этом они ссылаются на тот же объект, что и в базовом классе;

+ Константы наследуются производными классами. При этом они ссылаются на разные объекты для каждого подкласса;

+ Методы наследуются производными классами. При этом для каждого класса существует своя копия метода.

#### Агрегация

Агрегация - это технология языка, позволяющая сущности использовать структуру другой сущности путем включения (одна сущность может содержать ссылку на другие сущности). При удалении основной сущности, вложенные сущности продолжают существовать.

Реализация агрегации в Ruby позволяет добавлять функциональность модулей к объектам и их классам.

В Ruby реализована множественная агрегация. Это означает, что любой объект может включать произвольное количество модулей.

Включение модуля может быть выражено словом "содержит".

`.include(*a_module) # -> self [PRIVATE: Module]`

Используется для агрегации модулей. Агрегируемые модули добавляются в начало иерархии наследования. Равносильно копированию методов из модуля в класс объекта.

`.extend(*a_module) # -> object [Object]`

Используется для агрегации модулей. Агрегируемые модули добавляются в начало иерархии наследования собственного класса объекта. Равносильно копированию методов из модуля в собственный класс объекта.

`.extend_object(object) # -> object [PRIVATE]`

Используется для включения текущего объекта в состав переданного аргумента.  
`object.extend self`

~~~~~ note
  Выполнение выражения `extend self` в теле класса приведет к тому, что для каждого метода экземпляров автоматически объявляется соответствующий метод класса.
~~~~~

###### Ruby 2.0

**Во второй версии Ruby** добавлена возможность переопределять методы, определенные в классе.

`.prepend(*a_module) # -> self [PRIVATE: Module]`

Используется для агрегации модулей. Агрегируемые модули добавляются в начало очереди вызова методов. Также переопределяются константы и переменные. Методы, определенные в самом классе будут доступны с помощью super.

~~~~~ ruby
  module Foo
    def baz; 'foo-baz'; end
  end

  class Bat
    include Foo
    def baz; 'bat-baz'; end
  end
  Bar.new.baz # -> 'bat-baz'

  class Bar
    prepend Foo
    def baz; 'bar-baz'; end
  end
  Bar.new.baz # -> 'foo-baz'
~~~~~

Этот механизм облегчает полиморфизм методов. Если раньше приходилось расширять методы посредством создания промежуточных синонимов, то теперь можно просто агрегировать различные модули.

~~~~~ ruby
  # Ruby 1.9:
  class Range
    # Взято из active_support/core_ext/range/include_range.rb
    # Изменение Range#include? для поиска диапазонов.
    def include_with_range?(value)
      if value.is_a?(::Range)
        # 1...10 включает 1..9, но не 1..10.
        operator = exclude_end? && !value.exclude_end? ? :< : :<=
        include_without_range?(value.first) && value.last.send(operator, last)
      else
        include_without_range?(value)
      end
    end

    alias_method_chain :include?, :range
  end

  Range.ancestors # -> [ Range, Enumerable, Object... ]

  # Ruby 2.0
  module IncludeRangeExt
    # Изменение Range#include? для поиска диапазонов.
    def include?(value)
      if value.is_a?(::Range)
        # 1...10 включает 1..9, но не 1..10.
        operator = exclude_end? && !value.exclude_end? ? :< : :<=
        super(value.first) && value.last.send(operator, last)
      else
        super
      end
    end
  end

  class Range
    prepend IncludeRangeExt
  end

  Range.ancestors # -> [ IncludeRangeExt, Range, Enumerable, Object... ]
~~~~~

#### Иерархия наследования

Иерархия классов объекта - это последовательность классов, в которых выполняется поиск вызываемого метода (в Ruby иерархия классов содержит также и модули).

+ На вершине иерархии находится класс BasicObject, от него наследует класс Object, в теле которого выполняется программа.

+ Класс Object включает модуль Kernel, в котором определено большинство основных методов.

+ Любой модуль относится к экземплярам класса Module, который наследует класс Object. Методы экземпляров из класса Module могут вызываться в теле модулей.

+ Любой класс относится к экземплярам класса Class, который наследует класс Module. Методы экземпляров из класса Class могут вызываться в теле классов.

+ Методы экземпляров из класса Module могут вызываться в теле классов. Методы экземпляров из класса Class не могут вызываться в теле модулей.

Иерархия классов может изменяться в ходе выполнения программы.

+ базовый класс и его иерархия добавляются в начало иерархии для экземпляров производного класса;

+ собственный класс всегда находится в начале иерархии;

+ включение модуля добавляет его в начало иерархии;

### Полиморфизм

Реализация полиморфизма в Ruby позволяет переопределять унаследованные методы.

**Виртуальные методы:** методы, которые могут быть переопределены производным классом, так что конкретная реализация метода будет вычислена во время выполнения. В Ruby все методы относятся к виртуальным. Это значит что программист не обязан знать точный тип объекта, если у него имеется набор виртуальных методов - достаточно будет информации о принадлежности к требуемому классу.

Для переопределения метода, в теле класса, объявляют метод с тем же идентификатором.

Чтобы в теле унаследованного метода использовать метод базового класса вызывают инструкцию super, которой передаются необходимые аргументы (по умолчанию передаются все аргументы).

**Абстрактный метод:** метод, который был объявлен, но не определен. В Ruby все абстрактные методы считаются определенными и возвращают ссылку на nil.

**Абстрактный класс:** класс, содержащий хотя бы один виртуальный метод. Абстрактные классы используются только в иерархии наследования и не предназначены для создания экземпляров. Можно сказать, что абстрактные классы - это прототипы для создания других классов.

В Ruby создание экземпляров абстрактных классов по умолчанию не ограничивается, и фактически абстрактные классы не отличаются от обычных.

~~~~~ note
  Класс Numeric, к которому относятся все числа - типичный абстрактный класс, а класс IO, к которому относятся файлы и потоки, абстрактным не является. В любом случае синтаксис определения этих классов не отличается.
~~~~~

**Интерфейс:** обязательства (контракт), которые берет на себя класс. Интерфейсы описывают функциональность, предоставляемую классом, реализующим интерфейс. Класс, реализующий интерфейс, должен определять все его методы. Один класс может реализовывать несколько интерфейсов одновременно.

Обычно интерфейсы реализуются как модули, содержащие только абстрактные методы.

~~~~~ ruby
  module Openable
    def open; end
    def close; end
  end
~~~~~

###### Переопределение операторов

Одной из полезных особенностей в Ruby является то, что большинство операторов на самом деле относятся к методам. Поэтому поведение операторов для разных типов объектов отличается - оно зависит от определения метода в теле класса. Также разрешается определять собственное поведение для различных операторов и переопределять уже существующее. Выражение, составленное с помощью операторов, при этом аналогично вызову метода с тем же идентификатором.

~~~~~ ruby
  <op> object <-> object.<op>
  first_object <op> second_object <-> first_object.<op>(second_object)
~~~~~

Операторы, не относящиеся к методам:  
`., ::, &&, ||, ?:, =, псевдооператоры, not, and, or, .., ...`
