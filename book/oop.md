# Реализация ООП в Ruby

Одна из главных особенностей Ruby - сильно выраженная поддержка объектно-ориентированной парадигмы.

+ Любые данные, в том числе и элементарные - это объекты.
+ Большинство операторов относится к методам. Определив метод с соответствующим именем, можно использовать операторы с создаваемыми объектами.

+ Легко создавать классы. Каждый объект является представителем какого-либо класса, определяющего структуру объекта;
+ Легко создавать методы для доступа к свойствам объекта.
+ Легко наследовать методы.
+ Легко изменять унаследованные методы.

## Основные сущности

### Классы (Class)

Класс в Ruby - это тип объектов, хранящих информацию о структуре своих экземпляров и механизме их создания. Как объекты, все классы принадлежат к классу Class.

Создание класса называется объявлением, а описание его экземпляров - определением.

~~~~~ ruby
  class идентификатор_класса
    тело_класса
  end
~~~~~

+ Инструкция class ожидает получения константы, сообщая интерпретатору область памяти в которую необходимо выполнить запись информации.

~~~~~ ruby
  # Создание класса.
  class NewClass
    # code
  end
~~~~~

+ Если соответствующей области не существует, то автоматически объявляется новый класс. В другом случае будет изменен уже существующий класс. Любой класс (даже встроенный) может быть переопределен в любом месте кода.

~~~~~ ruby
  # Создание класса.
  class NewClass
    # code
  end

  # Изменение класса.
  class NewClass
    # code
  end
~~~~~

+ В теле класса создается отдельная область видимости. В ней может определяться поведение экземпляров класса или любые другие сущности.

+ В результате создания класса возвращается результат выполнения последнего выражения в теле класса (обычно это nil).

~~~~~ ruby
  # Создание класса.
  a = class NewClass
    # code
  end

  a # -> nil
~~~~~

+ Внутри тела класса псевдопеременная self ссылается на класс.

~~~~~ ruby
  class NewClass
    self # -> <Class: NewClass>
  end
~~~~~

+ Вне тела класса использованная константа ссылается на класс.

~~~~~ ruby
  class NewClass
    # code
  end

  NewClass # -> <Class: NewClass>
~~~~~

### Поведение объектов

Поведение экземпляров класса определяется описанными в нем методами. Возможность определять методы экземпляров - это главное отличие классов от остальных сущностей.

Методы - это абстрактные сущности, определяющие действия, которые может выполнять экземпляр класса, и действия, которые можно выполнять с самим экземпляром (например, изменять его состояние). Выполняемые действия делятся на два вида: функции и процедуры. В Ruby их четкого синтаксического разграничения не существует - процедуры входят в подмножество функций.

+ _Функция_ - это метод, используемый для получения результата (например математические функции);

  _Процедура_ - это метод, используемый для выполнения действия (например сохранение данных в файл). В результате выполнения процедуры обычно возвращается статус выполнения (логическая величина) или объект, для которого вызывалась процедура.

#### Определение

~~~~~ ruby
  class NewClass
    def new_method(params)
      code
    end
  end
~~~~~

+ Методы также можно назвать именованными фрагментами кода (именованными выражениями), возвращающими результат выполнения этого кода.

+ Методы определяются с помощью предложения `def/end`. Инструкция `def` ожидает получение идентификатора метода и набора параметров. Запись идентификатора метода аналогична записи локальной переменной. Параметры - это группа локальных переменных, идентифицирующих данные, передаваемые методу при вызове. Параметры существуют только в теле того метода, для которого были определены.

+ В теле метода псевдопеременная `self` будет ссылаться на экземпляр, для которого метод был вызван.

+ В результате определения возвращается nil.

+ Для объявления синонима метода (копии метода, имеющей другой идентификатор) существует инструкция `alias`. Для метода может быть определено любое количество синонимов. Синонимы могут быть созданы только в теле класса, объявляющего метод.

~~~~~ ruby
  class NewClass
    def new_method(params)
      code
    end

    # Запомнить синтаксис выражения будет проще,
    # если рассматривать его относительно выражения
    # присваивания: синоним = метод.
    alias my_method new_method
  end
~~~~~

+ Для удаления метода существует инструкция undef. Ее можно использовать только в теле класса, определяющего данный метод или в теле его подклассов (в этом случае метод будет удален только для отдельного подкласса).

~~~~~ ruby
  class NewClass
    def new_method(params)
      code
    end

    undef new_method
  end
~~~~~

Обычно имя метода выбирается в соответствии с его целью:

+ Для именования процедур используются глаголы (`create_file`);
+ Имя функции обычно описывает возвращаемый результат (`device`);
+ Имя методов с побочным эффектом заканчивается восклицательным знаком (добавляется только если существует версия метода без побочного эффекта - `save/save!`);
+ Предикаты - это методы, утверждающие или отрицающие что-либо об экземпляре. В результате выполнения предиката возвращается логическая величина, характеризующая истинность или ложность утверждения. Имя предиката обычно заканчивается вопросительным знаком (`new_record?`).

#### Использование

~~~~~ ruby
  object.new_method(arguments)
~~~~~

+ Использование методов также называют их вызовом. Ну, или отправкой сообщений объекту.

+ Методы вызываются с помощью бинарного оператора `.` (или `::`, но он обычно не используется). Левым операндом должен быть объект, для которого вызывается метод (получатель сообщения), а правым операндом - идентификатор метода (тип сообщения), вместе с аргументами (передаваемыми данными).

+ Использование круглых скобок при вызове метода не обязательно;

~~~~~ ruby
  object.new_method arguments
~~~~~

+ Вызов метода без указания объекта вызывает его для псевдопеременной self.

~~~~~ ruby
  new_method(arguments)
  self.new_method(arguments)
~~~~~

+ В результате вызова метода, возвращается результат выполнения последнего выражения в его теле.

~~~~~ ruby
  class NewClass
    def new_method(params)
      code
      1
    end
  end

  aNewClass.new_method # -> 1
~~~~~

+ Ход выполнения метода может регулироваться с помощью инструкции `return`. Необязательный код, передаваемый инструкции становится результатом выполнения метода (по умолчанию возвращается nil).

~~~~~ ruby
  class NewClass
    def new_method(params)
      return if true
    end
  end

  aNewClass.new_method # -> nil
~~~~~

~~~~~ ruby
  class NewClass
    def new_method(params)
      return 1 if true
    end
  end

  aNewClass.new_method # -> 1
~~~~~

#### Аргументы и параметры

~~~~~ ruby
  class NewClass
    def new_method(parameter)
      return parameter
    end
  end

  aNewClass.new_method(1) # -> 1
~~~~~

Параметры - это группа локальных переменных, идентифицирующих данные, передаваемые методу при вызове. Параметры существуют только в теле того метода, для которого были определены.

Аргументы - это данные (группа объектов, передаваемые методу при вызове).

При объявлении пераметра, метод ДОЛЖЕН получить соответствующий аргумент при вызове. Отсутствие аргумента считается ошибкой.

+ Метод может принимать несколько аргументов. В этом случае принимаемые параметры и передаваемые аргументы разделяют запятыми.

~~~~~ ruby
  class NewClass
    def new_method(first, second)
      return first + second
    end
  end

  aNewClass.new_method(1, 2) # -> 3
~~~~~

+ Метод может иметь параметры с значениями по умолчанию. Отсутствие аргумента для этого параметра просто будет считаться использованием значения по умолчанию. Такие параметры также можно назвать необязательными. Для объявления значения по умолчанию, при определении параметра, используют выражение присваивания. Значения по умолчанию могут быть произвольными выражениями, переменными экземпляра или даже другими параметрами, объявленными ранее. Параметры, имеющие значение по умолчанию, должны объявляться один за другим (не допускается объявление обязательных параметров между объявлениями необязательных).

~~~~~ ruby
  class NewClass
    def new_method(parameter = 0)
      return parameter
    end
  end

  aNewClass.new_method    # -> 0
  aNewClass.new_method(1) # -> 1
~~~~~

+ Метод можеть принимать произвольное количество аргументов. Для этого, перед параметром, который будет хранить массив из переданных аргументов, записывают оператор `*`. Параметры для хранения произвольного количества аргументов должны объявляться после всех необязателных параметров. Допускается существование только одного такого параметра для метода;

~~~~~ ruby
  class NewClass
    def new_method(*parameter)
      return parameter
    end
  end

  aNewClass.new_method(1,2,3) # -> [1,2,3]
~~~~~

+ Метод может принимать именнованные аргументы. При вызове метода аргумент передается вместе с именем, соответствующим одному из объявленных параметров (имя и аргумент разделяются двоеточием). Параметр для хранения именованного аргумента заканчивается двоеточием. Значение по умолчанию может быть объявлено после двоеточия.

~~~~~ ruby
  class NewClass
    def new_method(first:, last: 0)
      return first + last
    end
  end

  aNewClass.new_method(first: 1)          # -> 1
  aNewClass.new_method(first: 1, last: 2) # -> 3
~~~~~

+ Метод может принимать произвольное количество именованных аргументов. Для этого, перед параметром, который будет хранить ассоциативный массив из переданных аргументов и их имен, записывают оператор `**`.

~~~~~ ruby
  class NewClass
    def new_method(**parameters)
      return parameters
    end
  end

  aNewClass.new_method(first: 1, last: 2)
  # -> { first: 1, last: 2 }
~~~~~

+ Когда последним аргументом передается ассоциативный массив, то использование фигурных скобок необязательно.

~~~~~ ruby
  class NewClass
    def new_method(parameters)
      return parameters
    end
  end

  aNewClass.new_method(first: 1, last: 2)
  # -> { first: 1, last: 2 }
~~~~~

+ Аргументы метода могут быть объединены в массив. В этом случае, при вызове метода, используется оператор `*`.

~~~~~ ruby
  class NewClass
    def new_method(first, second)
      return first + second
    end
  end

  aNewClass.new_method(*[1, 2]) # -> 3
~~~~~

+ Именованные аргументы могут быть объединены в ассоциативный массив. В этом случае, при вызове метода, используется оператор `**`. Несколько ассоциативных массивов подряд будут объединяться.

~~~~~ ruby
  class NewClass
    def new_method(first:, last: 0)
      return first + last
    end
  end

  aNewClass.new_method(**{first: 1, last: 2})
  aNewClass.new_method(**{first: 1}, **{last: 2})
  # -> 3
~~~~~

~~~~~ note
Для повышения читабельности параметров, ссылающихся на логическую величину может использоваться приставка is.
~~~~~

#### Блоки

~~~~~ ruby
  aNewClass.new_method { code }

  aNewClass.new_method do
    code
  end
~~~~~

Блоки - одна из особенных синтаксических конструкций в Ruby, позволяющая методам выполнять произвольный код. С точки зрения синтаксиса, блоки можно описать как фрагменты кода, связанные с группой параметров.

+ Открывающая фигурная скобка или инструкция do относятся к предыдущему выражению - остальные аргументы метода необходимо ограничивать круглыми скобками.

~~~~~ ruby
  aNewClass.new_method(1,2) { code }
~~~~~

~~~~~ ruby
  class NewClass
    def new_method
      yield
    end
  end

  aNewClass.new_method { 1 }
  # -> 1

  aNewClass.new_method { 1 + 2 }
  # -> 3
~~~~~

Блоки не могут использоваться сами по себе, а только передаваться методам. Тело блока будет выполнено методом, в момент использования инструкции `yield`. Инструкция возвращает результат выполнения блока (результат последнего выполненного выражения по умолчанию). Отсутствие блока при использовании инструкции yield считается ошибкой.

+ Параметры блока объявляются между двумя вертикальными чертами, перед началом тела блока.

~~~~~ ruby
  aNewClass.new_method { |params| code }

  aNewClass.new_method do |params|
    code
  end
~~~~~

+ Аргументы передаются блоку с помощью инструкции `yield`. Лишние аргументы игнорируются.

~~~~~ ruby
  class NewClass
    def new_method(x,y)
      yield x,y
    end
  end

  aNewClass.new_method(1,2) { |x,y| x + y }
  # -> 3
~~~~~

+ Блок может иметь несколько параметров. В этом случае их разделяют запятыми.

~~~~~ ruby
  aNewClass.new_method { |first, last| code }
~~~~~

+ Блок не может иметь параметров с значениями по умолчанию.

+ Блок может принимать произвольное число аргументов. Для этого, перед параметром, который будет хранить массив из переданных аргументов, записывают оператор `*`.

~~~~~ ruby
  aNewClass.new_method { |*first| code }
~~~~~

Ход выполнения блока может регулироваться с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции становится результатом выполнения (по умолчанию nil).

##### Инструкции:

`break [код]` - используется для завершения выполнения блока и принимающего блок метода;

`redo` - используется для повторного выполнения блока.

*****

В теле блока создается новая область видимости. Псевдопеременная self ссылается на объект, для которого был вызван метод, принимающий блок.

+ Блок относится к замыканиям - в теле блока существуют локальные переменные, объявленные в окружающем коде.

~~~~~ ruby
  x = 1
  y = 2

  aNewClass.new_method do |x|
    x # -> 1
    y # -> 2
  end
~~~~~

+ Чтобы явно указать переопределение локальных переменных, их идентификаторы отделяют от параметров блока точкой с запятой. Переопределенные локальные переменные в теле блока будут ссылаться на nil.

~~~~~ ruby
  x = 1
  y = 2

  aNewClass.new_method do |x; y|
    x # -> 1
    y # -> nil
  end
~~~~~

### Состояние объектов

Состояние экземпляров класса определяется значениями объявленных в нем переменных и констант.

#### Константы

Константы используются для хранения не изменяющихся данных, известных до создания экземпляра и общих для всех экземпляров класса.

~~~~ ruby
  class NewClass
    NewConstant = "value"
  end
~~~~

+ Использовать константу можно с помощью оператора `::`. В качестве левого операнда используется идентификатор класса, а в качестве правого операнда - константа. Использование константы называют ее вызовом.

~~~~~ ruby
  NewClass::NewConstant # -> "value"
~~~~~

+ Использование этого выражения с оператором присваивания `=`, позволяет изменить константу в любом месте кода.

~~~~~ ruby
  NewClass::NewConstant = "value"
~~~~~

+ При отсутствии левого операнда по умолчанию используется псевдопеременная self.

~~~~ ruby
  class NewClass
    NewConstant = "value"
    NewConstant # -> "value"
    NewClass::NewConstant # -> "value"
  end
~~~~

#### Переменные

Переменные используются для хранения изменяющихся данных: состояния класса и его экземпляров. В ООП переменные могут иметь две дополнительные области видимости: область видимости класса и область видимости экземпляра класса.

**Переменные класса:** переменные, существующие в области видимости класса.

~~~~~ ruby
class NewClass
  @@class_variable = "value"
end
~~~~~

Переменные класса могут быть объявлены в любом месте тела класса (в том числе и в теле метода). Запись переменной начинается с символов `@@`.

Переменная класса может быть использована в любом месте тела класса (в том числе и в теле метода). Она имеет одинаковое значение для всех его экземпляров.

Переменные класса используются для хранения изменяющихся данных, общих для всех экземпляров класса. Обычно переменные класса инициализируются в теле класса и используются его методами. Использование несуществующей переменной класса считается ошибкой.

**Переменные экземпляра:** переменные, существующие в области видимости экземпляра класса.

~~~~~ ruby
class NewClass
  @instance_variable = "value"
end
~~~~~

Переменные экземпляра могут быть объявлены в теле метода. Лексема переменной начинается с символа @.

Переменная экземпляра может быть использована в теле любого метода экземпляров. Она имеет собтвенное значение для каждого отдельного экземпляра.

Переменные экземпляра используются для хранения состояния экземпляров класса. Обычно переменные экземпляра инициализируются в теле метода (в момент его вызова). Использование несуществующей переменной экземпляра считается её объявлением.

Если определить переменную экземпляра в теле класса, а не в теле метода, то она будет связана с классом, а не с его экземплярами. Такие переменные недоступны в теле методов и фактически относятся к переменным экземпляра объекта, принадлежащего к классу Class.

### Экземпляры классов

~~~~~ ruby
  NewClass.new # -> object
~~~~~

Объекты, создаваемые с помощью классов, называют его экземплярами.

+ Методы, используемые для создания объекта, называются конструкторами. По умолчанию в Ruby для каждого класса определен конструктор `::new`. Этот метод выполняет два действия: создает область памяти для объекта (используя метод `.allocate`) и заполняет эту область (используя метод `.initialize`).

+ Метод `.initialize` обычно определяется разработчиком. Этот метод также принмает аргументы, переданные при создании объекта.

~~~~~ ruby
  class NewClass
    def initialize(message)
      @message = message
    end

    def message
      @message
    end
  end

  aNewClass = NewClass.new("Hello World!")
  aNewClass.message # -> "Hello World!"
~~~~~

~~~~~ note
  Конструктор ".new" определен в классе Class, а значит доступен для всех классов.
  Метод .allocate уже определен в классе Class и его переопределение обычно не требуется.
~~~~~

### Собственные классы объектов

Каждый объект кроме класса, к экземплярам которого относится (и с помощью которого был создан), имеет еще и свой собственный класс. С помощью собственных классов для объектов определяется уникальное поведение (отличающиеся от поведения экземпляров того же класса). Собственные классы также называют метаклассами.

~~~~~ ruby
  class << object
    # тело класса
  end
~~~~~

Собственный класс объекта может быть изменен с помощью специального предложения.

+ Псевдопеременная self ссылается на объект.
+ Предложение возвращает результат выполнения последнего выражения (обычно это nil).


~~~~~ ruby
  class << object
    def own_method
      "Own"
    end
  end

  object.own_method # -> "Own"
~~~~~

Методы, объявленные в теле собственного класса будут доступны только одному объекту (собственный класс которого был изменен). Их также называют собственными методами объекта.

+ Собственные методы объекта могут быть определены с помощью специального синтаксиса определения метода, при котором указывается объект.

~~~~~ ruby
  def object.own_method
    "Own"
  end

  object.own_method # -> "Own"
~~~~~

+ Собственные методы объектов имеют доступ ко всем свойствам объекта.

+ Собственные методы объектов, определенные для классов, также называют методами класса.

~~~~~ ruby
  class << NewClass
    def class_method
      "Class"
    end
  end

  NewClass.class_method # -> "Class"
~~~~~

~~~~~ ruby
  class NewClass
    class << self
      def class_method
        "Class"
      end
    end

    def instance_method
      "Instance"
    end
  end

  NewClass.class_method    # -> "Class"
  NewClass.instance_method # -> "Instance"
~~~~~

~~~~~ ruby
  def NewClass.class_method
    "Class"
  end

  NewClass.class_method # -> "Class"
~~~~~

~~~~~ ruby
  class NewClass
    def self.class_method
      "Class"
    end

    def instance_method
      "Instance"
    end
  end

  NewClass.class_method    # -> "Class"
  NewClass.instance_method # -> "Instance"
~~~~~

### Модули (Module)

#### Определение

~~~~~ ruby
  module <идентификатор_модуля>
    <тело_модуля>
  end
~~~~~

Модули - это тип объектов, использующийся для инкапсуляции методов или констант. Как объекты, все классы принадлежат к классу Module.

Создание модуля называется объявлением, а заполнение области видимости модуля - определением.

+ Инструкция module ожидает получения константы, сообщая интерпретатору область памяти в которую необходимо выполнить запись информации. В теле модуля существует локальная область видимости.

~~~~~ ruby
  # Создание модуля.
  a = module NewModule
    # Внутри модуля ссылается на него
    self # -> <Module: NewModule>
  end

  # Возвращается результат выполнения
  # последнего выражения в теле модуля
  a # -> обычно это nil

  # Константа ссылается на модуль
  NewModule # -> <Module: NewModule>
~~~~~

+ Если соответствующей области не существует, то автоматически объявляется новый модуль. В другом случае будет изменен уже существующий модуль. Любой модуль (даже встроенный) может быть переопределен в любом месте кода.;

~~~~~ ruby
  # Создание модуля.
  module NewModule
    # code
  end

  # Изменение модуля.
  module NewModule
    # code
  end
~~~~~

#### Агрегация

В отличии от классов, модули могут хранить методы экземпялров, но не могут создавать экземпляры или производные модули. Поэтому модули учавствую в агрегации, а не в наследовании.

Агрегация - это добавление к новой сущности структуры уже существующей. Существует возможность агрегации нескольких стурктур в одну. Агрегация в Ruby позволяет классам использовать функциональность нескольких модулей.

`.include(*module) # -> self`

Используется для агрегации модулей объектом, для которого метод был вызван (обычно это класс). Может быть выражено, как "класс <содержит, включает, добавляет> функциональность модуля" и равносильно копированию методов из агрегируемого модуля в класс.

~~~~~ ruby
  module NewModule
    def new_method
      "Module"
    end
  end

  class NewClass
    include NewModule
  end

  NewClass.new.new_method # -> "Module"
~~~~~

`.extend(*module) # -> object`

Используется для агрегации модулей собственным классом объекта, для которого метод был вызван (обычно это класс). Может быть выражено, как "класс <использует, расширяет> функциональность модуля" и равносильно копированию методов из агрегируемого модуля в собственный класс объекта.

~~~~~ ruby
  module NewModule
    def new_method
      "Module"
    end
  end

  class NewClass
    extend NewModule
  end

  NewClass.new_method # -> "Module"
~~~~~

~~~~~ note
  Выполнение выражения `extend self` в теле класса приведет к тому, что для каждого метода экземпляров автоматически объявляется соответствующий метод класса.
~~~~~

#### Пространства имен

Модули могут быть использованы как пространства имен, инкапсулирующие структуру или поведение, в теле модуля. При этом все классы или модули программы объявляются только в теле одного отдельного модуля. Это позволяет разным программам не засорять глобальную область видимости. Использование глобальной области видимости программой считается плохим тоном среди программистов, т.к. требует согласования использованных имен классов и модулей и может привести к непредсказуемым последствиям.

Явно выраженный пример инкапсуляции логически связанных фрагментов кода представляет модуль Math, объединяющий математические функции.

~~~~~ ruby
  module MyApp
    VERSION = "1.0.0"

    def self.module_method
      "Module"
    end

    class NewClass
    end
  end

  MyApp::VERSION      # -> "1.0.0"
  MyApp.module_method # -> "Module"
  MyApp::NewClass     # -> new_class
~~~~~

## Основные принципы

### Инкапсуляция

#### Инкапсуляция состояния

По умолчанию, состояние объекта (значение переменных экземпляра) доступно только внутри объекта. Для получения или изменения состояния объекта должны быть определены соотвествующие методы.

+ Методы для получения значения свойства объекта обычно имеют тоже имя, что и свойство.

~~~~~ ruby
  class NewClass
    def name_of_attribute
      @name_of_attribute
    end
  end

  NewClass.new.name_of_attribute
  # -> @name_of_attribute
~~~~~

+ Методы для изменения значения свойства объекта обычно имеют тоже имя, что и свойство, но заканчиваются знаком присваивания. Это позвоялет использовать их на месте левого операнда в выражении присваивания.

~~~~~ ruby
  class NewClass
    def name_of_attribute=(value)
      @name_of_attribute = value
    end
  end

  NewClass.new.name_of_attribute = value
~~~~~

Чтобы сразу определить и свойство объекта и методы для его получения и изменения, в Ruby существуют специальные методы для классов.

`.attr_accessor(*attribute) # -> nil`

Объявление переменной экземпляра и методов для получения и изменения её значения.

~~~~~ ruby
  class NewClass
    attr_accessor :name_of_attribute
  end

  NewClass.new.name_of_attribute = value
  NewClass.new.name_of_attribute # -> value
~~~~~

`.attr_reader(*attribute) # -> nil`

Объявление переменной экземпляра и метода для получения её значения.

~~~~~ ruby
  class NewClass
    attr_accessor :name_of_attribute
  end

  NewClass.new.name_of_attribute
~~~~~

`.attr_writer(*attribute) # -> nil`

Объявление переменной экземпляра и метода для изменения её значения.

~~~~~ ruby
  class NewClass
    attr_accessor :name_of_attribute
  end

  NewClass.new.name_of_attribute = value
~~~~~

#### Инкапсуляция поведения

Определяемые методы также могут быть ограничены областью видимости, откуда они могут быть вызваны.

_public_ - общедоступные методы. Инкапсулируют общедоступное поведение объекта. Могут быть вызваны в любой области видимости. По умолчанию все методы относятся к общедоступным;

_protected_ - защищенные методы. Инкапсулируют общедоступное поведение объектов одного класса. Могут быть вызваны только в области видимости класса для любого из его экземляров;

_private_ - частные методы. Инкапсулируют конкретную реализацию общедоступного поведения объекта. Могут быть вызваны только в области видимости класса (и его производных) или экземпляров класса (и его производных) и только для текущего экземпляра (частные методы всегда вызываются для псевдопеременной self).

Для инкапсуляции общедоступного поведения, в Ruby существуют специальные методы, доступные для всех классов и модулей.

`.public`

Объявление всех методов, объявленных далее, общедоступными.

~~~~~ ruby
  class NewClass
    def raise_with_self
      self.public_method
    end

    def raise_without_self
      public_method
    end

    def public_method
      "Success"
    end
  end

  NewClass.new.public_method      # -> "Success"
  NewClass.new.raise_with_self    # -> "Success"
  NewClass.new.raise_without_self # -> "Success"
~~~~~

`.protected`

Объявление всех методов, объявленных далее, защищенными.

~~~~~ ruby
  class NewClass
    def raise_with_self
      self.protected_method
    end

    def raise_without_self
      protected_method
    end

    def raise_for_other_instance(new_class)
      new_class.protected_method
    end

    protected
      def protected_method
        "Success"
      end
  end

  NewClass.new.protected_method     # -> error!
  NewClass.new.raise_with_self      # -> "Success"
  NewClass.new.raise_without_self   # -> "Success"

  NewClass.new.raise_for_other_instance(NewClass.new)
  # -> "Success"
~~~~~

`.private`

Объявление всех методов, объявленных далее, частными.

~~~~~ ruby
  class NewClass
    def raise_with_self
      self.private_method
    end

    def raise_without_self
      private_method
    end

    def raise_for_other_instance(new_class)
      new_class.private_method
    end

    private
      def private_method
        "Success"
      end
  end

  NewClass.new.private_method     # -> error!
  NewClass.new.raise_with_self    # -> error!
  NewClass.new.raise_without_self # -> "Success"

  NewClass.new.raise_for_other_instance(NewClass.new)
  # -> error!
~~~~~


`.private_class_method(*name) # -> self`

Используется для объявления методов класса частными. Обычно применяется для инкапсуляции конструкторов.

~~~~~ ruby
  class NewClass
    private_class_method :new

    def self.create(*args)
      @result = new(*args) unless @result
      @result
    end
  end
~~~~~

`.public_class_method(*name) # -> self`

Используется для объявления методов класса общими.

### Наследование

В Ruby реализовано единичное наследование. Это означает, что любой класс может иметь только один базовый класс. Базовый класс объвляется при создании класса с помощью оператора `<`.

~~~~~ ruby
  class Parent
    CONSTANT = "Parent"

    @@class_variable = "Parent"

    def self.class_variable
      @@class_variable
    end

    def self.class_variable=(value)
      @@class_variable = value
    end

    def parent_method
      "Parent"
    end
  end

  class Child < Parent
    def child_method
      "Child"
    end
  end

  # Переменные класса наследются.
  Child.class_variable  # -> "Parent"
  Child.class_variable  = "Child"
  Parent.class_variable # -> "Child"

  # Константы наследуются
  # Но ссылаются на разные области
  # памяти.
  Child::CONSTANT  # -> "Parent"
  Child::CONSTANT  = "Child"
  Parent::CONSTANT # -> "Parent"

  # Методы экземпляров наследуются.
  # Но только в одну сторону.
  Child.new.child_method   # -> "Child"
  Child.new.parent_method  # -> "Parent"
  Parent.new.child_method  # -> error!
  Parent.new.parent_method # -> "Parent"
~~~~~

### Полиморфизм

Возможность полиморфизма в Ruby существует за счет иерархии вызова методов и констант. Когда интерпретатор, встречает в коде метод или константу, то он ищет их определение, продвигаясь вверх по иерархии.

#### Поиск констант

~~~~~ note
При изучении примеров, попробуйте последовательно раскомментировать разные строки, чтобы проверить правильность порядка.
~~~~~

1. В классе, в котором была вызвана константа;

~~~~~ ruby
  class BaseClass
    CONSTANT = "BaseClass"

    def constant
      CONSTANT
    end
  end

  BaseClass.new.constant # -> "BaseClass"
~~~~~

2. В модуле, в котором определяется класс;

~~~~~ ruby
  module BaseModule
    CONSTANT = "BaseModule"

    class BaseClass
      # CONSTANT = "BaseClass"

      def constant
        CONSTANT
      end
    end
  end

  BaseModule::BaseClass.new.constant # -> "BaseModule"
~~~~~

3. В модуле, добавленном к классу;

~~~~~ ruby
  module BaseModule
    # CONSTANT = "BaseModule"

    module NestedModule
      CONSTANT = "NestedModule"
    end

    class BaseClass
      # CONSTANT = "BaseClass"

      include NestedModule

      def constant
        CONSTANT
      end
    end
  end

  BaseModule::BaseClass.new.constant # -> "NestedModule"
~~~~~

4. Вверх по иерархии наследования с выполнением пунктов 1-3;

~~~~~ ruby
  module BaseModule
    # CONSTANT = "BaseModule"

    module NestedModule
      # CONSTANT = "NestedModule"
    end

    class BaseClass
      CONSTANT = "BaseClass"
    end

    class ChildClass < BaseClass
      # CONSTANT = "ChildClass"

      include NestedModule

      def constant
        CONSTANT
      end
    end
  end

  BaseModule::ChildClass.new.constant # -> "BaseClass"
~~~~~

5. Вызов метода `::const_missing`, для класса, в котором была вызвана константа.

~~~~~ ruby
  class BaseClass
    def constant
      CONSTANT
    end

    def self.const_missing(name)
      return name
    end
  end

  BaseClass.new.constant # -> :CONSTANT
~~~~~

#### Поиск методов

1. В собственном классе объекта;

~~~~~ ruby
  class BaseClass
  end

  object = BaseClass.new

  def object.new_method
    "Metaclass"
  end

  object.new_method # -> "Metaclass"
~~~~~

2. В классе объекта;

~~~~~ ruby
  class BaseClass
    def new_method
      "BaseClass"
    end
  end

  BaseClass.new.new_method # -> "BaseClass"
~~~~~

3. В модуле, добавленном к классу;

~~~~~ ruby
  module BaseModule
    def new_method
      "BaseModule"
    end
  end

  class BaseClass
    include BaseModule
  end

  BaseClass.new.new_method # -> "BaseModule"
~~~~~

4. Вверх по иерархии классов с выполнением пунктов 2 и 3;

~~~~~ ruby
  module BaseModule
    def new_method
      "BaseModule"
    end
  end

  class BaseClass
    include BaseModule
  end

  class ChildClass < BaseClass
  end

  ChildClass.new.new_method # -> "BaseModule"
~~~~~

5. Вызов для объекта метода `.method_missing`.

~~~~~ ruby
  class BaseClass
    def method_missing(name, *args)
      return name
    end
  end

  BaseClass.new.new_method # -> :new_method
~~~~~

С помощью инструкции `super` можно сообщить интерпретатору продолжить поиск дальше по иерархии. Инструкция может принимать аргументы, передаваемые дальше (найденному методу). По умолчанию инструкция передает все аргументы, переданные текущему методу.

~~~~~ ruby
  module BaseModule
    def new_method(message)
      print "BaseModule"
      print message
    end
  end

  class BaseClass
    include BaseModule

    def new_method(message)
      print "BaseClass"
      super(message)
    end
  end

  class ChildClass < BaseClass
    def new_method(message)
      print "ChildClass"
      super
    end
  end

  object = ChildClass.new

  def object.new_method(message)
    print "Metaclass"
    super
  end

  object.new_method
  # -> "Metaclass"
  # -> "ChildClass"
  # -> "BaseClass"
  # -> "BaseModule"
~~~~~

#### Дополнительные сущности

Полиморфизм привел к существованию дополнительных абстрактных сущностей.

**Виртуальные методы:** методы, которые могут быть переопределены производным классом, так что конкретная реализация метода будет вычислена во время выполнения. В Ruby все методы относятся к виртуальным. Это значит что программист не обязан знать точную структуру объекта, если у него имеется набор виртуальных методов - достаточно будет информации о принадлежности к требуемому классу.

**Абстрактный метод:** метод, который был объявлен, но не определен. В Ruby все абстрактные методы считаются определенными и возвращают ссылку на nil.

**Абстрактный класс:** класс, содержащий хотя бы один виртуальный метод. Абстрактные классы используются только в иерархии наследования и не предназначены для создания экземпляров. Можно сказать, что абстрактные классы - это прототипы для создания других классов.

В Ruby создание экземпляров абстрактных классов по умолчанию не ограничивается, и фактически абстрактные классы не отличаются от обычных.

**Интерфейс:** сущность, описывающая функциональность, предоставляемую классом, реализующим интерфейс. Класс должен определять все методы интерфейса. Один класс может реализовывать несколько интерфейсов одновременно. Модно сказать, что класс принимает на себя обязательство (контракт) реализовать функциональность, описанную интерфейсом.

Обычно интерфейсы реализуются как модули, содержащие только абстрактные методы.

~~~~~ ruby
  module Openable
    def open; end
    def close; end
  end

  class NewClass
    include Openable

    def open
      @status = :opened
    end

    def close
      @status = :closed
    end
  end
~~~~~
