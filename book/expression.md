## Выражения

Выражение - это команда, возвращающая результат выполнения (обычно это объект) в место своего вызова. Выражения делятся на простые и сложные. Стандартные объекты и идентификаторы относятся к простым выражениям. Для выполнения вычислений из простых выражений создаются сложные выражения и предложения (которые являются одной из разновидностей сложных выражений). Части сложного выражения соединяются с помощью операторов и инструкций.

### Предложения

Предложения - это одна из разновидностей сложных выражений, создаваемая с помощью инструкций (поэтому количество возможных видов предложений строго ограничено). Каждое предложение начинается с инструкции, объявляющей тип предложения и заканчивается инструкцией end, объявляющей конец предложения. Между этими двумя инструкциями находится фрагмент кода, называемый телом предложения, ходом выполнения которого манипулирует предложение.

#### Условное предложение

Условные предложения управляют ходом выполнения в зависимости от логического значения переданного условия. В результате выполнения предложения возвращается результат выполнения последнего выражения в его теле (или nil).

###### Синтаксис предложения:

Тело предложения выполняется при положительном результате вычисления условия.

~~~~~ ruby
  if условие
    тело_предложения
  end
~~~~~

Тело предложения должно быть отделено от условия либо переводом строки, либо точкой с запятой, либо инструкцией then.

###### Инструкция else:

Содержит фрагмент кода, который выполняется при отрицательном результате вычисления условия.

~~~~~ ruby
  ...
    тело_предложения
  else
    код
  end
~~~~~

При необходимости записать подряд инструкцию else и новое условное предложение используется инструкция elsif.

###### Краткий синтаксис:

`тело_предложения if условие`

Тело предложения либо должно находиться на одной строке с условием, либо быть ограничено инструкциями begin и end, либо быть ограничено двумя круглыми скобками.

~~~~~ ruby
  begin
    тело_предложения
  end if условие
~~~~~

или

~~~~~ ruby
  ( тело_предложения
  ) if условие
~~~~~

Если вместо инструкции if использовать инструкцию unless, то тело предложения будет выполняться при отрицательном результате вычисления условия. Инструкция elsif в этом случае не используется.

#### Разветвленное условие

Разветвленные условия похожи на условные предложения, но позволяют проверять сразу несколько условий. Условия проверяются последовательно. Обычно наиболее вероятные варианты записывают раньше остальных - это уменьшит время выполнения предложения. В результате выполнения предложения возвращается результат выполнения последнего выражения в его теле (или nil).

###### Синтаксис предложения:

Выполняется фрагмент кода с положительным результатом вычисления условия.

~~~~~ ruby
  case
    when условие
      код
    when условие
      код
    ...
  end
~~~~~

Условие может состоять из нескольких выражений, разделенных запятыми. Любое из них может послужить причиной для выполнения кода.

###### Специальный синтаксис:

Проверяется равенство значения условия и указанных выражений (с помощью `===`).

~~~~~ ruby
  case условие
  when выражение
    код
  when выражение
    код
  ...
  end
~~~~~

В любой форме можно использовать инструкцию else.

#### Цикл

Цикл - это предложение итеративного типа (заставляющее программу повторно выполнять некоторый фрагмент кода). Циклы используются в том случае, когда число итераций неизвестно заранее. В результате выполнения цикла возвращается ссылка на nil.

~~~~~ note
Цикл while не соответствует слову "пока" в естественном языке. Условие цикла не проверяется непрерывно, а только до или после каждой итерации.
~~~~~

###### Синтаксис предложения:

Тело предложения выполняется до тех пор пока результат вычисления условия истинен (условие проверяется до итерации).

~~~~~ ruby
  while условие
    тело_цикла
  end
~~~~~

Тело цикла должно быть отделено от условия либо переводом строки, либо точкой с запятой, либо инструкцией do.

###### Сокращенный синтаксис:

`тело_цикла while условие`

Тело цикла и условие обязательно должны находиться на одной строке кода. Если тело цикла ограничено инструкциями begin и end, то условие проверяется после итерации. Также тело цикла может быть ограничено двумя круглыми скобками.

~~~~~ ruby
  begin
    тело_цикла
  end while условие
~~~~~

или

~~~~~ ruby
  ( тело_цикла
  ) while условие
~~~~~

Если вместо инструкции while использовать инструкцию until, то тело цикла будет выполняться до тех пор пока результат вычисления условия ложен.

~~~~~ note
Использование инструкции until эквивалентно конструкции while not.

Для создания бесконечного цикла существует частный метод экземпляров из модуля Kernel - \verb`.loop { }`, который используется для бесконечного выполнения блока до возникновения исключения \verb`StopIteration` или вызова специальных инструкций. Данный метод эквивалентен конструкции while true.
~~~~~

#### Перебор элементов

Перебор элементов - это предложение итеративного типа, выполняющее фрагмент кода для каждого элемента составного объекта.

~~~~~ ruby
  for параметр in объект
    тело_перебора
  end
~~~~~

Параметр в теле перебора ссылается на элементы составного объекта (может быть использовано несколько параметров, разделенных запятыми).

Для составного объекта должен существовать метод `.each`, который будет использоваться в ходе выполнения предложения.

Тело предложения должно быть отделено либо переводом строки, либо точкой с запятой, либо инструкцией do.

#### Управление ходом выполнения

Ход выполнения предложения может быть изменен с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции возвращается в результате выполнения предложения. Если код отсутствует, то возвращается ссылка на nil.

##### Инструкции:

`return [код]` - используется для завершения выполнения предложения и всех методов, в теле которых оно выполняется, продвигаясь вверх по областям видимости;

`break [код]` - используется для завершения выполнения предложения;

`next [код]` - используется для завершения текущей итерации цикла и начала следующей;

`redo` - используется для повторного выполнения текущей итерации. Проверка условия при этом не выполняется.

*****

### Триггеры

В качестве условия могут быть использованы триггеры. Триггер - это сложное выражение, составленное с помощью операторов `..` или `...`. Эти операторы имеют приоритет выполнения больше, чем у оператора условия и меньше, чем у оператора логического ИЛИ (примерно 12.5). В условии может использоваться только один триггер.

Как и обычные условия, триггеры имеют некоторое логическое значение. Его особенность в том, что оно может изменяться в зависимости от результатов предыдущих вычислений, т.е. триггер сохраняет состояние выполнения.

Обычно триггеры применяются вместе с регулярными выражениями для обработки текста между начальными и конечными шаблонами.

###### Синтаксис триггера:

`условие..условие`; `условие...условие`

Операнды триггера - это два условия, при проверке которых логическое значение триггера либо остается неизменным, либо изменяется на противоположное. Порядок проверки условий зависит от оператора, используемого для создания триггера.

Значение триггера ложно до тех пор пока ложно значение первого условия. После смены логического значения первого условия изменяется и логическое значение триггера. Оно будет сохраняться до тех пор пока логическое значение второго условия ложно. После смены логического значения второго условия, изменяется и логическое значение триггера и проверка условий начинается сначала.

###### Процесс выполнения триггера:

1. Если логическое значение триггера ложно, то проверяется первое условие. В зависимости от его логического значения устанавливает логическое значение триггера. После его возвращения для оператора `..` также проверяется второе условие.

2. Если логическое значение триггера истинно, то проверяется второе условие. Если логическое значение второго условия истинно, то логическое значение триггера меняется.

~~~~~ note
По смыслу триггеры довольно похожи на диапазоны. Они верны до тех пор пока существующее состояние выполнения находится от достижения первого условия и до достижения второго условия. Оператор `...` включает состояние достигнувшее второе условие, а оператор `..` - нет.
~~~~~
