## IO (потоки)

**Добавленные модули: Enumerable и File::Constants**

Поток - это абстракция, используемая для ввода и вывода данных в единой манере. Вывод также называют чтением (извлечением) данных, а ввод - записью (передачей) данных.

Потоки являются удобным унифицированным программным интерфейсом для чтения или записи файлов (в том числе специальных и, в частности, связанных с устройствами), сокетов и передачи данных между процессами.

###### Модели ввода/вывода:

+ _блокирующая:_ процесс выполнения блокируется до тех пор пока ответ системы не будет записан в буфер приложения. Часто используется в отдельных процессах или потоках выполнения. К сожалению накладные расходы на создание процессов или потоков достаточно высоки.

  _неблокирующая:_ процесс выполнения не блокируется. При попытке получить данные до их записи в буфер, приложению отправляется сигнал. На основе обработки сигналов создается механизм опроса (polling) потоков. Опрос нескольких потоков приводит к большим накладным расходам.

  _мультиплексирование:_ опрос нескольких потоков в цикле. Возвращается первый доступный поток.

  _асинхронная:_ ядру дается команда начать операцию и уведомить приложение когда операция будет полностью завершена (включая запись в буфер приложения).

### Управление потоками

Виды потоков описаны в [приложении](appio).

#### Открытие потока

Для открытия потока требуется объект, с которым поток будет связан. Обычно это файл, но подойдет и экземпляр любого класса, производного от IO.

`::new( file, mode, options = nil ) # -> io`  
Синонимы: `for_fd`

Используется для открытия нового потока, связанного с переданным файлом. Создаваемый поток не может получить права доступа, отсутствующие при открытии файла.

`::open( file, mode, options = nil ) # -> io`


`( file, mode, options = nil ) { |io| } # -> object`

Версия предыдущего метода, позволяющая работать с потоком в теле блока (поток автоматически закрывается после завершения выполнения блока).

`::sysopen( path, mode = nil, *perm ) # -> integer`

Используется для низкоуровневого открытия файла. Возвращается файловый дескриптор.

`::copy_stream( old_io, new_io, start = nil, syze = nil ) # -> integer`

Используется для копирования содержимого потока. Возвращается количество скопированных байт. Дополнительные аргументы определяют начало и размер копируемого фрагмента. Если переданный размер превышает размер потока, то копирование выполняется до последнего байта.

#### Модификация потока

`.reopen(io) # -> self`

`( path, mode ) # -> self`

Используется для обновления потока.

`.binmode # -> self`

Используется для установки двоичного режима.

`.autoclose=(bool) # -> bool`

Используется для установки режима автоматического закрытия потока.

`.close_on_exec=(bool) # -> nil`

Метод используется чтобы запретить использование текущего файлового дескриптора в производных процессах выполнения.

**Во второй версии Ruby** ограничение по умолчанию устанавливается для всех дескрипторов. Чтобы передать файловый дескриптор другому процессу предполагается использование метода `.spawn`.

`.advise( symbol, start = 0, size = 0 ) # -> nil`

Используется для оптимизации работы с файлом. Дополнительные аргументы ограничивают фрагмент файла, с которым ведется работа.

+ _:normal_ - обычная работа (по умолчанию);  
  _:sequintial_ - последовательный доступ к данным;
  _:random_ - произвольный доступ к данным;  
  _:willneed_ - работа с файлом в ближайшем будущем;  
  _:dontneed_ - работа с файлом в ближайшем будущем выполняться не будет;  
  _:noreuse_ - работа с файлом будет выполняться только один раз.

`.fcntl( integer, object ) # -> integer2`

Низкоуровневое управление потоком см. fcntl(2).

`.ioctl( integer, object ) # -> integer2`

Низкоуровневое управление потоком см. ioctl(2).

#### Закрытие потока

Поток может быть закрыт автоматически сборщиком мусора.

`.close # -> nil`

Используется для закрытия потока и передачи всех изменений из буфера программы в ОС.

`.close_read # -> nil`

Используется для закрытия доступа на чтение. Невозможность операции (поток не связан с конвейером) считается исключением.

`.close_write # -> nil`

Используется для закрытия доступа для записи. Невозможность операции (поток не связан с конвейером) считается исключением.

#### Кодировка

`.external_encoding # -> encoding`

Внешняя кодировка. Если поток доступен для записи, но кодировка при этом не задана, то возвращается nil.

`.internal_encoding # -> encoding`

Внутренняя кодировка или nil.

`.set_encoding( *encoding, options = nil ) # -> io`

Используется для изменения внешней и внутренней кодировок. Опции применяются при [преобразовании кодировок](appencode).

#### Предикаты

`.autoclose? # -> bool`

Проверка автоматического закрытия потока.

`.binmode? # -> bool`

Проверка работы в двоичном режиме.

`.eof? # -> bool`  
Синонимы: `eof`

Проверка достижения конца файла (поток должен быть доступен для чтения). Если поток не связан с конвейером или сокетом, то процесс выполнения программы блокируется до тех пор пока не закончатся действия с данными или поток не будет закрыт.

`.tty? # -> bool`  
Синонимы: `isatty`

Проверка связи с терминалом. Если поток связан с терминалом, то вся информация, записанная в поток, будет отображаться в терминале. Данный предикат позволяет изменять формат вывода данных в зависимости от того, чем они будут отображены.

`.closed? # -> bool`

Проверка закрыт ли поток.

`.close_on_exec? # -> bool`

Метод используется для проверки доступа к файловому дескриптору из производного процесса.

~~~~~ ruby
  f = open '/dev/null'
  f.close_on_exec?                 # -> false
  f.close_on_exec = true
  f.close_on_exec?                 # -> true
  f.close_on_exec = false
  f.close_on_exec?                 # -> false
~~~~~

#### Остальное

`.stat # -> a_file_stat`

Используется для получения информации об открытом файле.

### Приведение типов

`::try_convert(object) # -> io`

Используется для преобразования аргумента в поток с помощью метода `.to_io`. Если такой метод не определен, то возвращается nil.

`.to_i # -> integer`  
Синонимы: `fileno`

Дескриптор файла.

`.to_io # -> io`

### Чтение данных

Поток должен быть доступен для чтения.

Дополнительные опции используются при открытии потока.

##### Опции:

`encoding:` внешняя кодировка. Игнорируется если указана размер фрагмента;

`mode:` вид создаваемого потока. Модификатор r обязателен;

`open_args:` массив аргументов, используемых при открытии файла.

*****

#### Фрагменты

`::read( path, start = nil, bytesize = nil, options = nil ) # -> string`

Используется для получения данных (по умолчанию всего файла). После чтения данных поток закрывается. Если размер требуемого фрагмента больше чем размер оставшихся данных, то извлекаются все данные.

`::binread( path, start = nil, size = nil ) # -> string`

Используется для получения двоичных данных в режиме "rb:ASCII".

`.read( bytesize = nil, buffer = nil ) # -> buffer`

Используется для получения данных из текущего потока (по умолчанию всех). Если размер фрагмента ограничен, то чтение выполняется в двоичном режиме. Дополнительный аргумент служит для хранения полученных данных.

+ Если передается ноль, то возвращается пустой текст;
+ Если в начале чтения достигнут конец файла, то возвращается ссылка nil (если размер фрагмента ограничен). В другом случае возвращается пустой текст.

`.sysread( bytesize, buffer = nil ) # -> buffer`

Используется для получения данных с помощью низкоуровневые возможности системы.

`.read_nonblock( bytesize, buffer = nil ) # -> buffer`

Используется для получения данных, не блокируя процесс выполнения, если система не готова выполнить запрос к файлу немедленно. Вместо этого программа принимает сигнал. Используется при реализации многопоточности на основе потоков выполнения или сопрограмм.

`.readpartial( bytesize, buffer = nil ) # -> buffer`

Используется для получения данных из конвейеров, сокетов и терминалов, блокируя процесс выполнения:

+ если буфер пуст;
+ если поток пуст;
+ если поток не достиг конца файла;

После блокировки ожидается получение данных или достижения конца файла. При получении данных они возвращаются, достижение конца файла считается исключением `EOFError`.

Процесс выполнения не блокируется, если поток содержит данные - в этом случае данные возвращаются.

Действие метода сходно с `io.sysread`, но, в отличии от него при возможности читает данные из буфера, вместо вызова исключения `IOError`. Также не вызываются `Errno::EWOULDBLOCK` и `Errno::EINTR`, а повторяется попытка чтения (метод игнорирует модификатор NONBLOCK).

#### Строки

`::readlines( path, sep = $/, options = nil ) # -> array`

`( path, size, options = nil ) # -> array`

`( path, sep, size, options = nil ) # -> array`

Используется для сохранения строк в массиве (размер массива может быть ограничен). Символом перевода строки считается переданный разделитель (если передается пустой текст, то обрабатывается "/n/n").

`.readlines( sep = $/, size = nil ) # -> array`

Версия метода для получения строк из текущего потока.

`.gets( sep = $/, bytesize = nil ) # -> string`

Используется для последовательного извлечения строк из потока (размер строки может быть ограничен). Символом перевода строки считается переданный разделитель (если передается пустой текст, то обрабатывается "/n/n"). Если достигнут конец файла, то возвращается nil.

Полученная в результате строка связывается с глобальной переменной `$_`.

`.readline( sep = $/, bytesize = nil ) # -> string`

Версия предыдущего метода, считающая достижение конца файла исключением.

`.lineno # -> integer`

Позиция (порядковый номер) извлекаемой строки (`$.`).

`.lineno=(pos) # -> integer`

Используется для изменения позиции (порядкового номера) извлекаемой строки. Позиция обновляется при последующем чтении данных из потока.

`.seek( offset, object = IO::SEEK_SET ) # -> 0`

Используется для изменения позиции (порядкового номера) извлекаемой строки относительно текущего положения и переданного смещения.

###### Константы:

+ `IO::SEEK_CUR` -> новая_позиция = текущая_позиция + offset  
  `IO::SEEK_END` -> новая_позиция = конец_файла + offset  
  `IO::SEEK_SET` -> новая_позиция = offset

`.sysseek( offset, object = IO::SEEK_SET ) # -> 0`

Версия предыдущего метода, использующая низкоуровневые возможности системы.

`.rewind # -> 0`

Используется для обнуления позиции (порядковый номер) извлекаемой строки. Метод не может быть вызван для потоков, связанных с конвейерами, терминалами или сокетами.

#### Символы

`.getc # -> string`

Используется для последовательного извлечения символов из потока. Если достигнут конец файла, возвращается nil.

`.readchar # -> string`

Версия предыдущего метода, считающая достижение конца файла исключением.

#### Байты

`.getbyte # -> integer`

Используется для последовательного извлечения байтов из потока. Если достигнут конец файла, возвращается nil.

`.readbyte # -> integer`

Версия предыдущего метода, считающая достижение конца файла исключением.

`.pos # -> integer`  
Синонимы: `tell`

Позиция (порядковый номер) извлекаемого байта.

`.pos=(pos) # -> integer`

Используется для изменения позиции (порядкового номера) извлекаемого байта. Позиция обновляется при последующем чтении данных из потока.

#### Итераторы

`::foreach( path, sep = $/, options = nil ) { |string| } # -> nil`

`( path, size, options = nil ) { |string| } # -> nil`

`( path, sep, size, options = nil ) { |string| } # -> nil`

Перебор строк (чтение выполняется с помощью `IO::readlines`).

`.each( sep = $/ ) { |string| } # -> self`

`(size) { |string| } # -> self`

`( sep, size) { |string| } # -> self`  
Синонимы: `each_line, lines`

Перебор строк (чтение выполняется с помощью `.readlines`). **Во второй версии Ruby** синоним lines признан устаревшим.

`.bytes { |byte| } # -> self`  
Синонимы: `each_byte`

Перебор байтов. **Во второй версии Ruby** синоним bytes признан устаревшим.

`.chars { |char| } # -> self`  
Синонимы: `each_char`

Перебор символов. **Во второй версии Ruby** синоним chars признан устаревшим.

`.codepoints { |point| } # -> self`  
Синонимы: `each_codepoint`

Перебор кодовых позиций. **Во второй версии Ruby** синоним codepoints признан устаревшим.

### Запись данных

Поток должен быть доступен для записи.

Перед записью аргументы преобразуются в текст с помощью метода `.to_s`.

Дополнительные опции используются при открытии потока.

##### Опции:

`encoding:` внешняя кодировка. Игнорируется если указана размер фрагмента;

`mode:` вид создаваемого потока. Модификатор r обязателен;

`perm:` права доступа к файлу;

`open_args:` массив аргументов, используемых при открытии файла.

*****

`::write( path, string, start = nil, options = nil ) # -> string.length`

Используется для записи фрагмента текста (по умолчанию - в конец файла). После записи данных файл закрывается.

`::binwrite( path, string, start = nil ) # -> string.length`

Используется для записи фрагмента в режиме "rb:ASCII-8BIT".

`.write(object) # -> object.to_s.bytesize`

Используется для записи текста.

`.syswrite(object) # -> object.to_s.bytesize`

Версия предыдущего метода, использующая низкоуровневые возможности системы.

`.<< object # -> io`

Используется для записи текста.

`.write_nonblock(string) # -> string.length`

Используется для записи данных, не блокируя процесс выполнения, если система не готова выполнить запрос к файлу немедленно. Вместо этого программа принимает сигнал. Используется при реализации многопоточности на основе потоков выполнения или сопрограмм. Буфер программы освобождается перед выполнением записью.

`.print( *object = $_ ) # -> nil`

Используется для записи всех переданных аргументов.

+ Если глобальная переменная `$,`, отвечающая за разделение элементов, не ссылается на nil, то она будет использоваться для разделения аргументов.

+ Если глобальная переменная `$\`, отвечающая за разделение данных, не ссылается на nil, то она будет использована после записи всех объектов.

`.printf( format, *objects ) # -> nil`

Используется для записи отформатированных данных `string % [*object]`.

`.putc(object) # -> object`

Используется для записи символов в поток. Переданное число считается кодовой позицией.

`.puts( *object = $\ ) # -> nil`

Используется для записи строк в поток. Аргументы разделяются с помощью символа перевода строки. Из индексного массива извлекаются все элементы.

#### Работа с буфером

Запись данных в файл выполняется автоматически, но не моментально. Сначала данные сохраняются в буфере программы, создаваемом интерпретатором. Поэтому бывает полезно периодически принудительно сохранять содержимое буфера на диск.

`.ungetbyte(object) # -> nil`

Используется для записи байтов в буфер (не повлияет на вызов низкоуровневых методов для чтения, например `io.sysread`).

`.ungetc(char) # -> nil`

Используется для записи символов в буфер (не повлияет на вызов низкоуровневых методов для чтения, например `io.sysread`).

`.fdatasync # -> 0`

Используется для сохранения буфера.

`.fsync # -> 0`

Используется для сохранения буфера.

`.flush # -> 0`

Используется для очищения буфера.

`.sync=(bool) # -> bool`

Используется для изменения режима синхронизации - любые записываемые данные сразу передаются операционной системе, а не записываются в буфер программы.

`.sync # -> bool`

Текущий режим синхронизации.

### Стандартные потоки

При запуске программы автоматически создаются три стандартных потока. Они позволяют передавать данные между системой и программой. По умолчанию стандартные потоки соединены с терминалом, из которого запущена программа.

##### Потоки:

`STDIN ($stdin)` - стандартный поток для чтения (ввода). Используется для получения команд пользователя или входных данных.

`STDOUT ($stdout, $>)` - стандартный поток для записи (вывода). Используется для передачи данных системе;

`STDERR ($stderr)` - стандартный поток для записи ошибок. Используется для вывода диагностичеких и отладочных сообщений.

*****

Отличие стандартного потока для записи от стандартного потока для записи ошибок в том что первый поток передается в конвейер, а второй нет. Стандартный поток для записи ошибок используют не только для вывода ошибок, но и для вывода любой другой информации о процессе работы программы, которая очевидно не должна попасть на вход другой программы.

#### Запись данных

Для записи данных в стандартный поток используются частные методы экземпляров из модуля Kernel. Они аналогичны соответствующим методам для записи в поток.

+ `Kernel.print`
+ `Kernel.printf`
+ `Kernel.putc`
+ `Kernel.puts`

`.display( io = $> ) # -> nil`

Используется для записи текущего объекта в переданный поток. По умолчанию используется стандартный поток для записи.

`.p(*args) # -> args`

Используется для записи информации об объекте (`object.inspect`) в стандартный поток для записи. Несколько аргументов объединяются с использованием разделителя `$/`

`.warn(message) # -> nil`

Используется для записи предупреждений в стандартный поток для записи. Выполнение программы продолжается.

**Во второй версии Ruby** принимает произвольное число аргументов как `IO.puts`. Аргументы разделяются с помощью символа перевода строки. Из индексного массива извлекаются все элементы.

#### Чтение данных

Для чтения данных из стандартного потока, используются частные методы экземпляров `kernel.gets` и `kernel.readline`. Они аналогичны соответствующим методам для чтения строк из потока.

С помощью этих методов программа также может получать данные уже после запуска.

### Конвейеры

Конвейер - это абстрактная сущность, объединяющая несколько процессов. Данные, записываемые в стандартный поток одним процессом, перенаправляются в стандартный поток другого процесса. В Linux создание конвейеров является главным способом взаимодействия программ запускаемых из терминала. Любой конвейер начинает работу как только появляются данные для обработки.

Обычно конвейеры анонимны и существуют только во время выполнения процесса. В отличии от них именованные конвейеры существуют в системе постоянно. Процессы периодически присоединяются к конвейеру для записи или чтения данных.

Создание анонимного конвейера: `<process> | <processs> | <process>`

Создание именованного контейнера: `mkfifo <name>`

Конвейеры можно использовать и в теле Ruby-программы.

`::pipe( *encoding, options = nil ) # -> array`

`( *encoding, options = nil ) { |read, write| } # -> object`

Используется для создания конвейера. Если методу передан блок, то потоки отправляются в блок и закрываются после его выполнения.

В качестве аргументов принимается кодировка. Переданные опции используются при [преобразовании кодировок](appencode).

~~~~~ ruby
  rd, wr = IO.pipe
  wr.puts "Text" # -> nil
  rd.gets "Text" # -> "Text\n"
~~~~~

### Мультиплексирование

Мультиплексирование потоков блокирует процесс выполнения, но снижает время ожидания, обрабатывая сразу несколько потоков.

`::select ( reads, writes = nil, errors = nil, sec = nil)`

Используется для мониторинга переданных потоков.

Возвращает массив, состоящий из подмассивов потоков, готовых к работе. Обычно возвращается поток, который освободился первым. Если время ожидания истекло, а ни один поток не готов, то возвращается nil.

~~~~~ ruby
  rp, wp = IO.pipe
  mesg = "ping "
  100.times {
    rs, ws, = IO.select([rp], [wp])
    if r = rs[0]
      ret = r.read(5)
      print ret
      case ret
      when /ping/
        mesg = "pong\n"
      when /pong/
        mesg = "ping "
      end
    end
    if w = ws[0]
      w.write(mesg)
    end
  }
  # ->
  ping pong
  ping pong
  ping pong
  (snipped)
  ping
~~~~~
